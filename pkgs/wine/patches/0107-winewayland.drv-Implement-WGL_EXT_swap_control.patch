From 1b57eb13ebbd374a3c2fcb515e242f3e38c35abe Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 24 Mar 2022 09:37:04 +0200
Subject: [PATCH 107/170] winewayland.drv: Implement WGL_EXT_swap_control.

Implement the wglSwapIntervalEXT and wglGetSwapIntervalEXT extension
functions by using the wl_surface frame callback to throttle
presentation when needed. The current implementation only supports swap
interval values of 0 and 1. Values over 1 are treated as a value of 1.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 116 ++++++++++++++++++++++++++++++++++
 1 file changed, 116 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 68319776b16..4c134151727 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -71,6 +71,8 @@ struct wayland_gl_drawable
     EGLSurface      surface;
     struct wl_event_queue *wl_event_queue;
     struct wl_list  buffer_list;
+    int             swap_interval;
+    struct wl_callback *throttle_callback;
 };
 
 struct wayland_gl_buffer
@@ -162,6 +164,7 @@ static struct wayland_gl_drawable *wayland_gl_drawable_create(HWND hwnd, int for
         if (!gl->wl_event_queue) goto err;
     }
     wl_list_init(&gl->buffer_list);
+    gl->swap_interval = 1;
 
     wayland_mutex_lock(&gl_object_mutex);
     wl_list_insert(&gl_drawables, &gl->link);
@@ -209,6 +212,7 @@ static void wayland_destroy_gl_drawable(HWND hwnd)
         if (gl->gbm_surface) gbm_surface_destroy(gl->gbm_surface);
         if (gl->wayland_surface)
             wayland_surface_unref_glvk(gl->wayland_surface);
+        if (gl->throttle_callback) wl_callback_destroy(gl->throttle_callback);
         if (gl->wl_event_queue) wl_event_queue_destroy(gl->wl_event_queue);
         free(gl);
         break;
@@ -395,6 +399,19 @@ err:
     return NULL;
 }
 
+static void throttle_callback(void *data, struct wl_callback *callback, uint32_t time)
+{
+    struct wayland_gl_drawable *draw_gl = data;
+
+    TRACE("hwnd=%p\n", draw_gl->hwnd);
+    draw_gl->throttle_callback = NULL;
+    wl_callback_destroy(callback);
+}
+
+static const struct wl_callback_listener throttle_listener = {
+    throttle_callback
+};
+
 static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
                                        struct wayland_gl_buffer *gl_buffer)
 {
@@ -409,6 +426,13 @@ static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
         wayland_surface_ensure_mapped(gl->wayland_surface);
         wl_surface_attach(gl_wl_surface, gl_buffer->dmabuf_buffer->wl_buffer, 0, 0);
         wl_surface_damage_buffer(gl_wl_surface, 0, 0, INT32_MAX, INT32_MAX);
+        if (gl->swap_interval > 0)
+        {
+            gl->throttle_callback = wl_surface_frame(gl_wl_surface);
+            wl_proxy_set_queue((struct wl_proxy *) gl->throttle_callback,
+                                gl->wl_event_queue);
+            wl_callback_add_listener(gl->throttle_callback, &throttle_listener, gl);
+        }
         wl_surface_commit(gl_wl_surface);
         committed = TRUE;
     }
@@ -417,6 +441,39 @@ static BOOL wayland_gl_drawable_commit(struct wayland_gl_drawable *gl,
     return committed;
 }
 
+static void wayland_gl_drawable_throttle(struct wayland_gl_drawable *gl)
+{
+    static const DWORD timeout = 100;
+    DWORD start, elapsed;
+
+    if (gl->swap_interval == 0) goto out;
+
+    start = NtGetTickCount();
+    elapsed = 0;
+
+    /* The compositor may at any time decide to not display the surface on
+     * screen and thus not send any frame events. Until we have a better way to
+     * deal with this, wait for a maximum of timeout for the frame event to
+     * arrive, in order to avoid blocking the GL thread indefinitely. */
+    while (gl->throttle_callback && elapsed < timeout &&
+           wayland_dispatch_queue(gl->wl_event_queue, timeout - elapsed) != -1)
+    {
+        DWORD now = NtGetTickCount();
+        /* Handle tick count wrap around to zero. */
+        if (now < start)
+            elapsed = 0xffffffff - start + now + 1;
+        else
+            elapsed = now - start;
+    }
+
+out:
+    if (gl->throttle_callback)
+    {
+        wl_callback_destroy(gl->throttle_callback);
+        gl->throttle_callback = NULL;
+    }
+}
+
 static BOOL wgl_context_refresh(struct wgl_context *ctx)
 {
     BOOL ret = InterlockedExchange(&ctx->refresh, FALSE);
@@ -892,6 +949,8 @@ static BOOL WINAPI wayland_wglSwapBuffers(HDC hdc)
         struct wayland_gl_buffer *gl_buffer;
         struct gbm_bo *bo;
 
+        wayland_gl_drawable_throttle(draw_gl);
+
         p_eglSwapBuffers(egl_display, draw_gl->surface);
 
         bo = gbm_surface_lock_front_buffer(draw_gl->gbm_surface);
@@ -921,6 +980,59 @@ out:
     return TRUE;
 }
 
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static int wayland_wglGetSwapIntervalEXT(void)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+    int swap_interval;
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        /* This can't happen because a current WGL context is required to get
+         * here. Likely the application is buggy.
+         */
+        WARN("No GL drawable found, returning swap interval 0\n");
+        return 0;
+    }
+
+    swap_interval = gl->swap_interval;
+    wayland_gl_drawable_release(gl);
+
+    return swap_interval;
+}
+
+/***********************************************************************
+ *		wayland_wglGetSwapIntervalEXT
+ */
+static BOOL wayland_wglSwapIntervalEXT(int interval)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    struct wayland_gl_drawable *gl;
+
+    TRACE("(%d)\n", interval);
+
+    if (interval < 0)
+    {
+        SetLastError(ERROR_INVALID_DATA);
+        return FALSE;
+    }
+
+    if (!(gl = wayland_gl_drawable_get(ctx->draw_hwnd)))
+    {
+        SetLastError(ERROR_DC_NOT_FOUND);
+        return FALSE;
+    }
+
+    gl->swap_interval = interval;
+
+    wayland_gl_drawable_release(gl);
+
+    return TRUE;
+}
+
 /***********************************************************************
  *		wayland_wglGetExtensionsStringARB
  */
@@ -991,6 +1103,10 @@ static void init_extensions(void)
     if (has_extension(egl_exts, "EGL_KHR_create_context"))
         has_khr_create_context = TRUE;
 
+    register_extension("WGL_EXT_swap_control");
+    egl_funcs.ext.p_wglSwapIntervalEXT = wayland_wglSwapIntervalEXT;
+    egl_funcs.ext.p_wglGetSwapIntervalEXT = wayland_wglGetSwapIntervalEXT;
+
     /* load standard functions and extensions exported from the OpenGL library */
 
 #define USE_GL_FUNC(func) if ((ptr = dlsym(opengl_handle, #func))) egl_funcs.gl.p_##func = ptr;
-- 
2.36.1

