From ed309a03af6b643a05c7cc6dbbbf9696df640aab Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:28:21 +0300
Subject: [PATCH 015/170] winewayland.drv: Update Windows monitor information
 on Wayland changes.

Whenever the Wayland output display state changes (including during
initialization), update the monitor information on the Windows side to
reflect these changes. The update happens when handling output events
targeting the per-process Wayland instance.

We currently support a single GPU, and a single monitor for each
adapter.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/display.c         | 142 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland.c         |   2 +
 dlls/winewayland.drv/wayland_output.c  |   3 +
 dlls/winewayland.drv/waylanddrv.h      |   5 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 6 files changed, 154 insertions(+)
 create mode 100644 dlls/winewayland.drv/display.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index b83bfd4405b..356e94684b0 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -9,6 +9,7 @@ CPPFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 
 C_SRCS = \
+	display.c \
 	dllmain.c \
 	wayland.c \
 	wayland_mutex.c \
diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
new file mode 100644
index 00000000000..7074e9dc7d6
--- /dev/null
+++ b/dlls/winewayland.drv/display.c
@@ -0,0 +1,142 @@
+/*
+ * WAYLAND display device functions
+ *
+ * Copyright 2019 Zhiyi Zhang for CodeWeavers
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static BOOL force_display_devices_refresh;
+
+static void wayland_refresh_display_devices(void)
+{
+    UINT32 num_path, num_mode;
+    force_display_devices_refresh = TRUE;
+    /* trigger refresh in win32u */
+    NtUserGetDisplayConfigBufferSizes(QDC_ONLY_ACTIVE_PATHS, &num_path, &num_mode);
+}
+
+void wayland_init_display_devices()
+{
+    wayland_refresh_display_devices();
+}
+
+static void wayland_add_gpu(const struct gdi_device_manager *device_manager,
+                            void *param)
+{
+    static const WCHAR wayland_gpuW[] = {'W','a','y','l','a','n','d','G','P','U',0};
+    struct gdi_gpu gpu = {0};
+    lstrcpyW(gpu.name, wayland_gpuW);
+
+    /* TODO: Fill in gpu information from vulkan. */
+
+    TRACE("id=0x%s name=%s\n",
+          wine_dbgstr_longlong(gpu.id), wine_dbgstr_w(gpu.name));
+
+    device_manager->add_gpu(&gpu, param);
+}
+
+static void wayland_add_adapter(const struct gdi_device_manager *device_manager,
+                                void *param, INT output_id)
+{
+    struct gdi_adapter adapter;
+    adapter.id = output_id;
+    adapter.state_flags = DISPLAY_DEVICE_ATTACHED_TO_DESKTOP;
+    if (output_id == 0)
+        adapter.state_flags |= DISPLAY_DEVICE_PRIMARY_DEVICE;
+
+    TRACE("id=0x%s state_flags=0x%x\n",
+          wine_dbgstr_longlong(adapter.id), adapter.state_flags);
+
+    device_manager->add_adapter(&adapter, param);
+}
+
+static void wayland_add_monitor(const struct gdi_device_manager *device_manager,
+                                void *param, struct wayland_output *output)
+{
+
+    struct gdi_monitor monitor = {0};
+    DWORD len = 0;
+
+    if (RtlUTF8ToUnicodeN(monitor.name, sizeof(monitor.name), &len,
+                          output->name, strlen(output->name) + 1))
+    {
+        monitor.name[0] = 0;
+    }
+
+    SetRect(&monitor.rc_monitor, output->x, output->y,
+            output->x + output->current_mode->width,
+            output->y + output->current_mode->height);
+
+    /* We don't have a direct way to get the work area in Wayland. */
+    monitor.rc_work = monitor.rc_monitor;
+
+    monitor.state_flags = DISPLAY_DEVICE_ATTACHED | DISPLAY_DEVICE_ACTIVE;
+
+    TRACE("name=%s rc_monitor=rc_work=%s state_flags=0x%x\n",
+          wine_dbgstr_w(monitor.name), wine_dbgstr_rect(&monitor.rc_monitor),
+          monitor.state_flags);
+
+    device_manager->add_monitor(&monitor, param);
+}
+
+/***********************************************************************
+ *      UpdateDisplayDevices (WAYLAND.@)
+ */
+void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param)
+{
+    struct wayland *wayland;
+    struct wayland_output *output;
+    INT output_id = 0;
+
+    if (!force && !force_display_devices_refresh) return;
+
+    TRACE("force=%d force_refresh=%d\n", force, force_display_devices_refresh);
+
+    force_display_devices_refresh = FALSE;
+
+    wayland = wayland_process_acquire();
+
+    wayland_add_gpu(device_manager, param);
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        if (!output->current_mode) continue;
+
+        /* TODO: Detect and support multiple monitors per adapter (i.e., mirroring). */
+        wayland_add_adapter(device_manager, param, output_id);
+        wayland_add_monitor(device_manager, param, output);
+
+        output_id++;
+    }
+
+    wayland_process_release();
+}
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 3098cb2b94b..daab7d26065 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -99,6 +99,8 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
         {
             TRACE("removing output->name=%s\n", output->name);
             wayland_output_destroy(output);
+            if (wayland_is_process(wayland))
+                wayland_init_display_devices();
             return;
         }
     }
diff --git a/dlls/winewayland.drv/wayland_output.c b/dlls/winewayland.drv/wayland_output.c
index 508f2c2a9ac..1a5f8c7b434 100644
--- a/dlls/winewayland.drv/wayland_output.c
+++ b/dlls/winewayland.drv/wayland_output.c
@@ -308,6 +308,9 @@ static void wayland_output_done(struct wayland_output *output)
               o->logical_x, output->logical_y, o->logical_w, o->logical_h,
               o->x, o->y, o->current_mode->width, o->current_mode->height);
     }
+
+    if (wayland_is_process(output->wayland))
+        wayland_init_display_devices();
 }
 
 static void output_handle_geometry(void *data, struct wl_output *wl_output,
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 07264b5b9d6..68c8cf740a5 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -32,9 +32,11 @@
 
 #include "windef.h"
 #include "winbase.h"
+#include "wingdi.h"
 #include "ntuser.h"
 
 #include "unixlib.h"
+#include "wine/gdi_driver.h"
 
 /**********************************************************************
  *          Globals
@@ -133,6 +135,7 @@ void wayland_deinit(struct wayland *wayland) DECLSPEC_HIDDEN;
 BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
 struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
 void wayland_process_release(void) DECLSPEC_HIDDEN;
+void wayland_init_display_devices(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland mutex
@@ -157,6 +160,8 @@ void wayland_output_use_xdg_extension(struct wayland_output *output) DECLSPEC_HI
  */
 
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
+                                  BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 0deac43ebc9..d08eb7838ea 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -87,6 +87,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
     .pThreadDetach = WAYLAND_ThreadDetach,
+    .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
 };
 
-- 
2.36.1

