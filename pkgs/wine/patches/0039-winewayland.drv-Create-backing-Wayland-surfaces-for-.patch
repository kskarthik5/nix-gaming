From 036efec44575fcfe34179bef04195688634abca3 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 3 Sep 2021 10:38:51 +0300
Subject: [PATCH 039/170] winewayland.drv: Create backing Wayland surfaces for
 windows.

Associate Wayland surfaces with windows that need to be displayed by
the native window system. This includes all kinds of top-level windows,
but not child windows, since children are rendered by Wine in the
window surface of their parent top-level.

As a special case, we use Wayland subsurfaces to display windows
that we believe are transient (e.g., popups) and need relative
positioning. We currently use a very simple heuristic to detect such
cases: windows that have an owner but no caption. Future commits
will refine this heuristic.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   4 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          | 168 +++++++++++++++++++++++++
 3 files changed, 173 insertions(+)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5d4540509e4..02ee0b24037 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -381,6 +381,10 @@ BOOL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DW
 void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface) DECLSPEC_HIDDEN;
 BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
                                const RECT *window_rect, const RECT *client_rect,
                                RECT *visible_rect, struct window_surface **surface) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 905c59e05ef..498271bcdf7 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -90,6 +90,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
+    .pWindowPosChanged = WAYLAND_WindowPosChanged,
     .pWindowPosChanging = WAYLAND_WindowPosChanging,
 };
 
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 9b84d15c19e..6f24456596a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -33,6 +33,7 @@
 
 #include "ntuser.h"
 
+#include <assert.h>
 #include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
@@ -48,6 +49,12 @@ struct wayland_win_data
     RECT           window_rect;
     /* client area relative to parent */
     RECT           client_rect;
+    /* wayland surface (if any) representing this window on the wayland side */
+    struct wayland_surface *wayland_surface;
+    /* whether this window is visible */
+    BOOL           visible;
+    /* whether a wayland surface update is needed */
+    BOOL           wayland_surface_needs_update;
 };
 
 static struct wayland_mutex win_data_mutex =
@@ -70,6 +77,7 @@ static void wayland_win_data_destroy(struct wayland_win_data *data)
     TRACE("hwnd=%p\n", data->hwnd);
     win_data_context[context_idx(data->hwnd)] = NULL;
 
+    if (data->wayland_surface) wayland_surface_unref(data->wayland_surface);
     free(data);
 
     wayland_mutex_unlock(&win_data_mutex);
@@ -123,6 +131,7 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
         return NULL;
 
     data->hwnd = hwnd;
+    data->wayland_surface_needs_update = TRUE;
 
     wayland_mutex_lock(&win_data_mutex);
     win_data_context[context_idx(hwnd)] = data;
@@ -132,6 +141,142 @@ static struct wayland_win_data *wayland_win_data_create(HWND hwnd)
     return data;
 }
 
+/***********************************************************************
+ *           wayland_surface_for_hwnd_unlocked
+ *
+ * Helper function to get the wayland_surface for a HWND without any locking.
+ * The caller should ensure that win_data_mutex has been locked before this
+ * operation, and for as long as the association between the HWND and the
+ * returned wayland_surface needs to remain valid.
+ */
+static struct wayland_surface *wayland_surface_for_hwnd_unlocked(HWND hwnd)
+{
+    struct wayland_win_data *data;
+
+    assert(win_data_mutex.owner_tid == GetCurrentThreadId());
+
+    if ((data = win_data_context[context_idx(hwnd)]) && data->hwnd == hwnd)
+        return data->wayland_surface;
+
+    return NULL;
+}
+
+static BOOL wayland_win_data_wayland_surface_needs_update(struct wayland_win_data *data)
+{
+    if (data->wayland_surface_needs_update)
+        return TRUE;
+
+    /* If this is currently or potentially a toplevel surface, and its
+     * visibility state has changed, recreate win_data so that we only have
+     * xdg_toplevels for visible windows. */
+    if (data->wayland_surface && !data->wayland_surface->wl_subsurface)
+    {
+        BOOL visible = data->wayland_surface->xdg_toplevel != NULL;
+        if (data->visible != visible)
+            return TRUE;
+    }
+
+    return FALSE;
+}
+
+static struct wayland_surface *update_surface_for_role(struct wayland_win_data *data,
+                                                       enum wayland_surface_role role,
+                                                       struct wayland *wayland,
+                                                       struct wayland_surface *parent_surface)
+{
+    struct wayland_surface *surface = data->wayland_surface;
+
+    if (!surface ||
+        (role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != WAYLAND_SURFACE_ROLE_NONE &&
+         surface->role != role))
+    {
+        surface = wayland_surface_create_plain(wayland);
+        if (surface) wayland_mutex_lock(&surface->mutex);
+    }
+    else
+    {
+        /* Lock the wayland surface to avoid other threads interacting with it
+         * while we are updating. */
+        wayland_mutex_lock(&surface->mutex);
+        wayland_surface_clear_role(surface);
+        /* Clear the associated HWND, to allow a potential invocation of
+         * wayland_surface_make_toplevel below, to properly handle the
+         * initial configure event. */
+        surface->hwnd = 0;
+    }
+
+    if (role == WAYLAND_SURFACE_ROLE_TOPLEVEL)
+        wayland_surface_make_toplevel(surface, parent_surface);
+    else if (role == WAYLAND_SURFACE_ROLE_SUBSURFACE)
+        wayland_surface_make_subsurface(surface, parent_surface);
+
+    surface->hwnd = data->hwnd;
+
+    wayland_mutex_unlock(&surface->mutex);
+
+    return surface;
+}
+
+static void wayland_win_data_update_wayland_surface(struct wayland_win_data *data)
+{
+    struct wayland *wayland;
+    HWND effective_parent_hwnd;
+    struct wayland_surface *surface;
+    struct wayland_surface *parent_surface;
+    DWORD style;
+
+    TRACE("hwnd=%p\n", data->hwnd);
+
+    data->wayland_surface_needs_update = FALSE;
+
+    wayland = thread_init_wayland();
+
+    /* GWLP_HWNDPARENT gets the owner for any kind of toplevel windows,
+     * and the parent for child windows. */
+    effective_parent_hwnd = (HWND)NtUserGetWindowLongPtrW(data->hwnd, GWLP_HWNDPARENT);
+    parent_surface = NULL;
+
+    if (effective_parent_hwnd)
+        parent_surface = wayland_surface_for_hwnd_unlocked(effective_parent_hwnd);
+
+    style = NtUserGetWindowLongW(data->hwnd, GWL_STYLE);
+
+    /* Use wayland subsurfaces for children windows and windows that are
+     * transient (i.e., don't have a titlebar). Otherwise, if the window is
+     * visible make it wayland toplevel. Finally, if the window is not visible
+     * create a plain (without a role) surface to avoid polluting the
+     * compositor with empty xdg_toplevels. */
+    if ((style & WS_CAPTION) != WS_CAPTION)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_SUBSURFACE,
+                                          wayland, parent_surface);
+    }
+    else if (data->visible)
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_TOPLEVEL,
+                                          wayland, parent_surface);
+    }
+    else
+    {
+        surface = update_surface_for_role(data, WAYLAND_SURFACE_ROLE_NONE,
+                                          wayland, parent_surface);
+    }
+
+    if (data->wayland_surface != surface)
+    {
+        if (data->wayland_surface)
+            wayland_surface_unref(data->wayland_surface);
+        data->wayland_surface = surface;
+    }
+}
+
+static void update_wayland_state(struct wayland_win_data *data)
+{
+    if (wayland_win_data_wayland_surface_needs_update(data))
+        wayland_win_data_update_wayland_surface(data);
+}
+
 /**********************************************************************
  *           WAYLAND_CreateWindow
  */
@@ -183,11 +328,34 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     data->parent = (parent == NtUserGetDesktopWindow()) ? 0 : parent;
     data->window_rect = *window_rect;
     data->client_rect = *client_rect;
+    data->visible = (style & WS_VISIBLE) == WS_VISIBLE || (swp_flags & SWP_SHOWWINDOW);
 
     wayland_win_data_release(data);
     return TRUE;
 }
 
+/***********************************************************************
+ *           WAYLAND_WindowPosChanged
+ */
+void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
+                              const RECT *window_rect, const RECT *client_rect,
+                              const RECT *visible_rect, const RECT *valid_rects,
+                              struct window_surface *surface)
+{
+    struct wayland_win_data *data;
+
+    if (!(data = wayland_win_data_get(hwnd))) return;
+
+    TRACE("hwnd %p window %s client %s visible %s style %08x after %p flags %08x\n",
+          hwnd, wine_dbgstr_rect(window_rect), wine_dbgstr_rect(client_rect),
+          wine_dbgstr_rect(visible_rect), NtUserGetWindowLongW(hwnd, GWL_STYLE),
+          insert_after, swp_flags);
+
+    update_wayland_state(data);
+
+    wayland_win_data_release(data);
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
-- 
2.36.1

