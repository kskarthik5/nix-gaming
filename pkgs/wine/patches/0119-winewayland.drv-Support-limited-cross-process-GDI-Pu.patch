From ff805e36fe0104924a512dd798ede70703ec595f Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 8 Apr 2022 12:46:48 +0300
Subject: [PATCH 119/170] winewayland.drv: Support limited cross-process GDI
 PutImage.

This is a fallback implementation for when the dibdrv cannot perform
this task, typically because the destination belongs to a different
process. In such a case the implementation utilizes the remote surface
infrastructure to commit content to the remote HWND.

The implementation is very limited, supporting only simple full copies,
but that's enough for some typical cross-process cases, notably software
rendered content on Chrome/CEF.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/gdi.c             | 145 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   3 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 3 files changed, 149 insertions(+)

diff --git a/dlls/winewayland.drv/gdi.c b/dlls/winewayland.drv/gdi.c
index 3b4e2727106..ca966c76288 100644
--- a/dlls/winewayland.drv/gdi.c
+++ b/dlls/winewayland.drv/gdi.c
@@ -25,8 +25,12 @@
 #include "config.h"
 
 #include "waylanddrv.h"
+#include "wine/debug.h"
 
 #include <stdlib.h>
+#include <sys/mman.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 typedef struct
 {
@@ -86,3 +90,144 @@ BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev)
     free(physDev);
     return TRUE;
 }
+
+/**********************************************************************
+ *           WAYLAND_PutImage
+ *
+ * This is a fallback implementation for when the dibdrv cannot perform
+ * this task, typically because the destination belongs to a different
+ * process. In such a case the implementation utilizes the remote surface
+ * infrastructure to commit content to the remote HWND.
+ *
+ * The implementation is very limited, supporting only simple full copies,
+ * but that's enough for some typical cross-process cases, notably software
+ * rendered content in Chrome/CEF.
+ */
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop)
+{
+    HWND hwnd;
+    struct wayland_native_buffer native;
+    struct wayland_remote_surface_proxy *remote = NULL;
+    size_t shm_size;
+    void *shm_data;
+    DWORD ret = ERROR_SUCCESS;
+
+    hwnd = NtUserWindowFromDC(dev->hdc);
+
+    TRACE("hwnd=%p rop=%#x biBitCount=%d compr=%d size=%dx%d "
+          "src=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "dst=log=%d,%d+%dx%d:dev=%d,%d+%dx%d:vis=%s "
+          "clip=%p\n",
+          hwnd, rop, info->bmiHeader.biBitCount,
+          info->bmiHeader.biCompression,
+          info->bmiHeader.biWidth, info->bmiHeader.biHeight,
+          src->log_x, src->log_y, src->log_width, src->log_height,
+          src->x, src->y, src->width, src->height,
+          wine_dbgstr_rect(&src->visrect),
+          dst->log_x, dst->log_y, dst->log_width, dst->log_height,
+          dst->x, dst->y, dst->width, dst->height,
+          wine_dbgstr_rect(&dst->visrect), clip);
+
+    if (info->bmiHeader.biPlanes != 1)
+    {
+        TRACE("Multiplanar buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biBitCount != 32)
+    {
+        TRACE("Non 32-bit buffers not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biCompression != BI_RGB)
+    {
+        TRACE("Non RGB not supported\n");
+        goto update_format;
+    }
+
+    if (info->bmiHeader.biHeight > 0)
+    {
+        TRACE("Bottom-up buffers not supported\n");
+        goto update_format;
+    }
+
+    if (!bits) return ERROR_SUCCESS;  /* just querying the format */
+
+    if (!hwnd)
+    {
+        TRACE("Invalid hwnd=%p\n", hwnd);
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (clip)
+    {
+        TRACE("Clipping not supported\n");
+        return ERROR_CLIPPING_NOT_SUPPORTED;
+    }
+
+    if ((src->width != dst->width) || (src->height != dst->height))
+    {
+        TRACE("Image stretching is not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if ((src->width != info->bmiHeader.biWidth) ||
+        (src->height != -info->bmiHeader.biHeight))
+    {
+        TRACE("Partial blits are not supported\n");
+        return ERROR_TRANSFORM_NOT_SUPPORTED;
+    }
+
+    if (rop != SRCCOPY)
+    {
+        TRACE("Raster operations other than SRCCOPY are not supported\n");
+        return ERROR_INVALID_OPERATION;
+    }
+
+    if (!wayland_native_buffer_init_shm(&native, src->width, src->height, 
+                                        WL_SHM_FORMAT_ARGB8888))
+    {
+        TRACE("Failed to create native shm buffer %dx%d\n", src->width, src->height);
+        return ERROR_OUTOFMEMORY;
+    }
+
+    shm_size = native.strides[0] * native.height;
+    shm_data = mmap(NULL, shm_size, PROT_WRITE, MAP_SHARED, native.fds[0], 0);
+    if (!shm_data)
+    {
+        TRACE("Failed to mmap shm buffer size=%zu\n", shm_size);
+        ret = ERROR_OUTOFMEMORY;
+        goto out;
+    }
+    memcpy(shm_data, bits->ptr, shm_size);
+    munmap(shm_data, shm_size);
+
+    remote = wayland_remote_surface_proxy_create(hwnd,
+                                                 WAYLAND_REMOTE_SURFACE_TYPE_NORMAL);
+    if (!remote)
+    {
+        TRACE("Failed to create remote surface proxy\n");
+        ret =  ERROR_OUTOFMEMORY;
+        goto out;
+    }
+
+    wayland_remote_surface_proxy_commit(remote, &native,
+                                        WAYLAND_REMOTE_BUFFER_TYPE_SHM,
+                                        WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
+                                        NULL, NULL);
+
+    wayland_remote_surface_proxy_destroy(remote);
+
+out:
+    wayland_native_buffer_deinit(&native);
+    return ret;
+
+update_format:
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    if (info->bmiHeader.biHeight > 0) info->bmiHeader.biHeight = -info->bmiHeader.biHeight;
+    return ERROR_BAD_FORMAT;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e001faf8ac7..e13e50e37a2 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -724,5 +724,8 @@ BOOL CDECL WAYLAND_CreateDC(PHYSDEV *pdev, LPCWSTR device,
                             LPCWSTR output, const DEVMODEW* initData) DECLSPEC_HIDDEN;
 BOOL CDECL WAYLAND_CreateCompatibleDC(PHYSDEV orig, PHYSDEV *pdev) DECLSPEC_HIDDEN;
 BOOL CDECL WAYLAND_DeleteDC(PHYSDEV dev) DECLSPEC_HIDDEN;
+DWORD CDECL WAYLAND_PutImage(PHYSDEV dev, HRGN clip, BITMAPINFO *info,
+                             const struct gdi_image_bits *bits, struct bitblt_coords *src,
+                             struct bitblt_coords *dst, DWORD rop) DECLSPEC_HIDDEN;
 
 #endif /* __WINE_WAYLANDDRV_H */
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 364153cdb37..5566a21a789 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -136,6 +136,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .dc_funcs.pCreateDC = WAYLAND_CreateDC,
     .dc_funcs.pCreateCompatibleDC = WAYLAND_CreateCompatibleDC,
     .dc_funcs.pDeleteDC = WAYLAND_DeleteDC,
+    .dc_funcs.pPutImage = WAYLAND_PutImage,
     .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
 
     .pChangeDisplaySettingsEx = WAYLAND_ChangeDisplaySettingsEx,
-- 
2.36.1

