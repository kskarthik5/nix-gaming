From 3700c183dc4146052bba69ecda277deb3342d168 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 15:38:48 +0300
Subject: [PATCH 073/170] winewayland.drv: Store a list of Wayland child
 surfaces.

Make each Wayland surfaces aware of its subsurfaces, and also maintain a
list of toplevel surfaces. This will allow us to efficiently apply
property changes (e.g., changing the output associated with a surface)
to whole surface tree hierarchies in upcoming commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |  5 +++
 dlls/winewayland.drv/wayland_surface.c | 52 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  3 ++
 3 files changed, 60 insertions(+)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index b3f97e29f0f..fb8cb2662f6 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -241,6 +241,7 @@ BOOL wayland_init(struct wayland *wayland)
 
     wl_list_init(&wayland->output_list);
     wl_list_init(&wayland->detached_shm_buffer_list);
+    wl_list_init(&wayland->toplevel_list);
 
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
@@ -289,6 +290,7 @@ void wayland_deinit(struct wayland *wayland)
 {
     struct wayland_output *output, *output_tmp;
     struct wayland_shm_buffer *shm_buffer, *shm_buffer_tmp;
+    struct wayland_surface *toplevel, *toplevel_tmp;
 
     TRACE("%p\n", wayland);
 
@@ -296,6 +298,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_remove(&wayland->thread_link);
     wayland_mutex_unlock(&thread_wayland_mutex);
 
+    wl_list_for_each_safe(toplevel, toplevel_tmp, &wayland->toplevel_list, link)
+        wayland_surface_destroy(toplevel);
+
     if (wayland->event_notification_pipe[0] >= 0)
         close(wayland->event_notification_pipe[0]);
     if (wayland->event_notification_pipe[1] >= 0)
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 3ca325b6fd3..40d17e80297 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -158,6 +158,8 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->link);
+    wl_list_init(&surface->child_list);
     wl_surface_set_user_data(surface->wl_surface, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
@@ -165,6 +167,10 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
 
+    /* Although not technically toplevel, plain surfaces have no parent, so
+     * track them in the toplevel list. */
+    wl_list_insert(&wayland->toplevel_list, &surface->link);
+
     return surface;
 
 err:
@@ -202,6 +208,9 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
 
+    /* Plain surfaces (which are the only kind can become toplevel) are
+     * already tracked in the toplevel_list, there is no need to readd. */
+
     wl_surface_commit(surface->wl_surface);
 
     surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
@@ -237,6 +246,14 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
     surface->drawing_allowed = TRUE;
 
     surface->parent = wayland_surface_ref(parent);
+
+    /* Remove from toplevel_list (added as a plain surface) and add to parent
+     * child list. */
+    wl_list_remove(&surface->link);
+    wayland_mutex_lock(&parent->mutex);
+    wl_list_insert(&parent->child_list, &surface->link);
+    wayland_mutex_unlock(&parent->mutex);
+
     surface->wl_subsurface =
         wl_subcompositor_get_subsurface(wayland->wl_subcompositor,
                                         surface->wl_surface,
@@ -270,6 +287,18 @@ void wayland_surface_clear_role(struct wayland_surface *surface)
 
     surface->drawing_allowed = FALSE;
 
+    if (surface->parent)
+    {
+        /* As a plain surface, this should now tracked in the toplevel_list. */
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+        wl_list_insert(&surface->wayland->toplevel_list, &surface->link);
+
+        wayland_surface_unref(surface->parent);
+        surface->parent = NULL;
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -520,6 +549,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
+    struct wayland_surface *child, *child_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -529,6 +559,20 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     if (keyboard->focused_surface == surface)
         keyboard->focused_surface = NULL;
 
+    /* There are children left only when we force a destruction during
+     * thread deinitialization, otherwise the children hold a reference
+     * to the parent and won't let it be destroyed. */
+    wayland_mutex_lock(&surface->mutex);
+    wl_list_for_each_safe(child, child_tmp, &surface->child_list, link)
+    {
+        /* Since the current surface (the parent) is being destroyed,
+         * disassociate from the child to avoid the child trying to
+         * destroy the parent. */
+        child->parent = NULL;
+        wayland_surface_destroy(child);
+    }
+    wayland_mutex_unlock(&surface->mutex);
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -555,9 +599,17 @@ void wayland_surface_destroy(struct wayland_surface *surface)
 
     if (surface->parent)
     {
+        wayland_mutex_lock(&surface->parent->mutex);
+        wl_list_remove(&surface->link);
+        wayland_mutex_unlock(&surface->parent->mutex);
+
         wayland_surface_unref(surface->parent);
         surface->parent = NULL;
     }
+    else
+    {
+        wl_list_remove(&surface->link);
+    }
 
     wayland_mutex_destroy(&surface->mutex);
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 32b45dc746e..5b72a345253 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -151,6 +151,7 @@ struct wayland
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
+    struct wl_list toplevel_list;
     struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
@@ -197,6 +198,7 @@ struct wayland_surface_configure
 
 struct wayland_surface
 {
+    struct wl_list link;
     struct wayland *wayland;
     struct wl_surface *wl_surface;
     struct wl_subsurface *wl_subsurface;
@@ -211,6 +213,7 @@ struct wayland_surface
     LONG ref;
     enum wayland_surface_role role;
     BOOL drawing_allowed;
+    struct wl_list child_list;
 };
 
 struct wayland_native_buffer
-- 
2.36.1

