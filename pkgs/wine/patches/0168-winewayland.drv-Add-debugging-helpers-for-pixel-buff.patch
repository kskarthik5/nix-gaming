From 77312d191e328a204b76df8d57b859ac46553820 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 13:36:40 +0300
Subject: [PATCH 168/170] winewayland.drv: Add debugging helpers for pixel
 buffer contents.

During development it's often useful to be able inspect the contents and
window or damage regions of the various buffers involved in software
rendering.

This commit adds helper functions to dump buffer contents to disk, and
uses them to dump the window buffer at flush time, the wayland SHM
buffers at commit time, and the front buffer at update/glFlush time.

These helpers are turned off by default and can be enabled by changing
the value of the corresponding preprocessor define.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/dump_pixels.c     | 174 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_surface.c |  12 ++
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/window_surface.c  |  25 ++++
 5 files changed, 214 insertions(+)
 create mode 100644 dlls/winewayland.drv/dump_pixels.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index ebd99390855..858d7b77896 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -15,6 +15,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	dump_pixels.c \
 	gbm.c \
 	gdi.c \
 	opengl.c \
diff --git a/dlls/winewayland.drv/dump_pixels.c b/dlls/winewayland.drv/dump_pixels.c
new file mode 100644
index 00000000000..5c3904b6b3d
--- /dev/null
+++ b/dlls/winewayland.drv/dump_pixels.c
@@ -0,0 +1,174 @@
+/*
+ * Debugging functions for pixel buffer contents
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntgdi.h"
+#include "winuser.h"
+
+#include <assert.h>
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static RGNDATA *get_region_data(HRGN region)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+
+    if (!region) return NULL;
+
+    if (!(size = NtGdiGetRegionData(region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+
+    if (!NtGdiGetRegionData(region, size, data)) goto err;
+
+    return data;
+
+err:
+    free(data);
+    return NULL;
+}
+
+/* Dump the contents of a pixel buffer, along with the outlines of damage
+ * and window regions, to a netpbm .pam file. */
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels,
+                 int width, int height, BOOL alpha, HRGN damage, HRGN win_region)
+{
+    char fname[128] = {0};
+    RGNDATA *damage_data;
+    RGNDATA *win_region_data;
+    FILE *fp;
+    int x, y;
+
+    damage_data = get_region_data(damage);
+    win_region_data = get_region_data(win_region);
+
+    snprintf(fname, sizeof(fname), fpattern, dbgid);
+    TRACE("dumping pixels to %s\n", fname);
+
+    fp = fopen(fname, "w");
+    assert(fp && "Failed to open target file for dump pixels. Does the target directory exist?");
+
+    fprintf(fp, "P7\nWIDTH %d\nHEIGHT %d\nDEPTH 4\nMAXVAL 255\nTUPLTYPE RGB_ALPHA\nENDHDR\n",
+            width, height);
+
+    for (y = 0; y < height; ++y)
+    {
+        for (x = 0; x < width; ++x)
+        {
+            BOOL draw_damage = FALSE;
+            BOOL draw_win_region = FALSE;
+            RECT *rgn_rect;
+            RECT *end;
+
+            if (damage_data)
+            {
+                rgn_rect = (RECT *)damage_data->Buffer;
+                end = rgn_rect + damage_data->rdh.nCount;
+
+                /* Draw the outlines of damaged areas. */
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_damage = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (win_region_data)
+            {
+                /* Draw the outlines of window region areas. */
+                rgn_rect = (RECT *)win_region_data->Buffer;
+                end = rgn_rect + win_region_data->rdh.nCount;
+
+                for (;rgn_rect < end; rgn_rect++)
+                {
+                    if ((y == rgn_rect->top ||
+                         y == rgn_rect->bottom - 1) &&
+                        x >= rgn_rect->left &&
+                        x < (rgn_rect->right))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                    if ((x == rgn_rect->left ||
+                         x == rgn_rect->right - 1) &&
+                        y >= rgn_rect->top &&
+                        y < (rgn_rect->bottom))
+                    {
+                        draw_win_region = TRUE;
+                        break;
+                    }
+                }
+            }
+
+            if (draw_damage || draw_win_region)
+            {
+                unsigned char rgba[4] = {
+                    draw_damage ? 0xff : 0x00,
+                    draw_win_region ? 0xff : 0x00,
+                    0x00, 0xff
+                };
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+            else
+            {
+                unsigned int *pixel = (unsigned int *)((char *)pixels +
+                                                       width * 4 * y + 4 * x);
+                unsigned char rgba[4] = {
+                    (*pixel & 0x00ff0000) >> 16,
+                    (*pixel & 0x0000ff00) >> 8,
+                    (*pixel & 0xff),
+                    alpha ? (*pixel & 0xff000000) >> 24 : 0xff,
+                };
+
+                fwrite(&rgba, sizeof(rgba), 1, fp);
+            }
+        }
+    }
+
+    fflush(fp);
+    fclose(fp);
+
+    free(damage_data);
+    free(win_region_data);
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index fee0761cea9..05d140480a0 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -34,6 +34,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump committed buffer contents to disk */
+#define DEBUG_DUMP_COMMIT_BUFFER 0
+
 static void wayland_surface_set_main_output(struct wayland_surface *surface,
                                             struct wayland_output *output);
 
@@ -612,6 +615,15 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
         return FALSE;
     }
 
+    if (DEBUG_DUMP_COMMIT_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/commit-%.4d.pam", dbgid++, shm_buffer->map_data,
+                    shm_buffer->width, shm_buffer->height,
+                    shm_buffer->format == WL_SHM_FORMAT_ARGB8888,
+                    shm_buffer->damage_region, NULL);
+    }
+
     wl_surface_attach(surface->wl_surface, shm_buffer->wl_buffer, 0, 0);
 
     /* Add surface damage, i.e., which parts of the surface have changed since
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 97839a55647..5167a4df16e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -699,6 +699,8 @@ size_t ascii_to_unicode_z(WCHAR *dst, size_t dst_max_chars,
 LONG unicode_z_to_long(LPCWSTR s, LPWSTR *end, INT base) DECLSPEC_HIDDEN;
 int wayland_shmfd_create(const char *name, int size) DECLSPEC_HIDDEN;
 void wayland_get_client_rect_in_win_coords(HWND hwnd, RECT *client_rect) DECLSPEC_HIDDEN;
+void dump_pixels(const char *fpattern, int dbgid, unsigned int *pixels, int width, int height,
+                 BOOL alpha, HRGN damage, HRGN win_region) DECLSPEC_HIDDEN;
 
 /**********************************************************************
 >>>>>>> 1956eea5224 (winewayland.drv: Create dedicated window to handle clipboard messages.)
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index 56174e8dfbe..a74a3f7151e 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -40,6 +40,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+/* Change to 1 to dump flushed surface buffer contents to disk */
+#define DEBUG_DUMP_FLUSH_SURFACE_BUFFER 0
+
+/* Change to 1 to dump front buffer contents to disk when performing front
+ * buffer rendering. */
+#define DEBUG_DUMP_FRONT_BUFFER 0
+
 struct wayland_window_surface
 {
     struct window_surface header;
@@ -330,6 +337,15 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
 
     assert(wws->wayland_buffer_queue);
 
+    if (DEBUG_DUMP_FLUSH_SURFACE_BUFFER)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/flush-%.4d.pam", dbgid++, wws->bits,
+                    wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
+                    wws->wayland_buffer_queue->format == WL_SHM_FORMAT_ARGB8888,
+                    surface_damage_region, wws->total_region);
+    }
+
     wayland_buffer_queue_add_damage(wws->wayland_buffer_queue, surface_damage_region);
     buffer = wayland_buffer_queue_acquire_buffer(wws->wayland_buffer_queue);
     if (!buffer)
@@ -661,6 +677,15 @@ void wayland_window_surface_update_front_buffer(struct window_surface *window_su
         WARN("Failed to allocate memory for front buffer pixels\n");
     }
 
+    if (DEBUG_DUMP_FRONT_BUFFER && wws->front_bits)
+    {
+        static int dbgid = 0;
+        dump_pixels("/tmp/winewaylanddbg/front-%.4d.pam", dbgid++,
+                    wws->front_bits, wws->info.bmiHeader.biWidth,
+                    abs(wws->info.bmiHeader.biHeight),
+                    FALSE, NULL, NULL);
+    }
+
 out:
     window_surface->funcs->unlock(window_surface);
 }
-- 
2.36.1

