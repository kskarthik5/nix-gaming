From 717d29dabb9e4f5cace06764e06c2d4cdd924583 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 18:41:32 +0300
Subject: [PATCH 125/170] winewayland.drv: Implement vkCreateInstance.

Create a Vulkan instance, ensuring we use the proper (Wayland)
SurfaceKHR extension when forwarding the request to the native Vulkan
platform.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 93 ++++++++++++++++++++++++++++++++++-
 1 file changed, 92 insertions(+), 1 deletion(-)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index d4dc608c7e7..be064348c9c 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -35,20 +35,111 @@
 #include "wine/vulkan_driver.h"
 
 #include <dlfcn.h>
+#include <stdlib.h>
 
 WINE_DEFAULT_DEBUG_CHANNEL(vulkan);
 
 #ifdef SONAME_LIBVULKAN
 
+static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
+
 static void *vulkan_handle;
 
+/* Helper function for converting between win32 and Wayland compatible VkInstanceCreateInfo.
+ * Caller is responsible for allocation and cleanup of 'dst'.
+ */
+static VkResult wine_vk_instance_convert_create_info(const VkInstanceCreateInfo *src,
+                                                     VkInstanceCreateInfo *dst)
+{
+    unsigned int i;
+    const char **enabled_extensions = NULL;
+
+    dst->sType = src->sType;
+    dst->flags = src->flags;
+    dst->pApplicationInfo = src->pApplicationInfo;
+    dst->pNext = src->pNext;
+    dst->enabledLayerCount = 0;
+    dst->ppEnabledLayerNames = NULL;
+    dst->enabledExtensionCount = 0;
+    dst->ppEnabledExtensionNames = NULL;
+
+    if (src->enabledExtensionCount > 0)
+    {
+        enabled_extensions = calloc(src->enabledExtensionCount, sizeof(*src->ppEnabledExtensionNames));
+        if (!enabled_extensions)
+        {
+            ERR("Failed to allocate memory for enabled extensions\n");
+            return VK_ERROR_OUT_OF_HOST_MEMORY;
+        }
+
+        for (i = 0; i < src->enabledExtensionCount; i++)
+        {
+            /* Substitute extension with Wayland ones else copy. Long-term, when we
+             * support more extensions, we should store these in a list.
+             */
+            if (!strcmp(src->ppEnabledExtensionNames[i], "VK_KHR_win32_surface"))
+                enabled_extensions[i] = "VK_KHR_wayland_surface";
+            else
+                enabled_extensions[i] = src->ppEnabledExtensionNames[i];
+        }
+        dst->ppEnabledExtensionNames = enabled_extensions;
+        dst->enabledExtensionCount = src->enabledExtensionCount;
+    }
+
+    return VK_SUCCESS;
+}
+
+static VkResult wayland_vkCreateInstance(const VkInstanceCreateInfo *create_info,
+                                         const VkAllocationCallbacks *allocator,
+                                         VkInstance *instance)
+{
+    VkInstanceCreateInfo create_info_host;
+    VkResult res;
+    TRACE("create_info %p, allocator %p, instance %p\n", create_info, allocator, instance);
+
+    if (allocator)
+        FIXME("Support for allocation callbacks not implemented yet\n");
+
+    /* Perform a second pass on converting VkInstanceCreateInfo. Winevulkan
+     * performed a first pass in which it handles everything except for WSI
+     * functionality such as VK_KHR_win32_surface. Handle this now.
+     */
+    res = wine_vk_instance_convert_create_info(create_info, &create_info_host);
+    if (res != VK_SUCCESS)
+    {
+        ERR("Failed to convert instance create info, res=%d\n", res);
+        return res;
+    }
+
+    res = pvkCreateInstance(&create_info_host, NULL /* allocator */, instance);
+
+    free((void *)create_info_host.ppEnabledExtensionNames);
+    return res;
+}
+
 static void wine_vk_init(void)
 {
     if (!(vulkan_handle = dlopen(SONAME_LIBVULKAN, RTLD_NOW)))
+    {
         ERR("Failed to load %s.\n", SONAME_LIBVULKAN);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) if (!(p##f = dlsym(vulkan_handle, #f))) goto fail
+    LOAD_FUNCPTR(vkCreateInstance);
+#undef LOAD_FUNCPTR
+
+    return;
+
+fail:
+    dlclose(vulkan_handle);
+    vulkan_handle = NULL;
 }
 
-static const struct vulkan_funcs vulkan_funcs;
+static const struct vulkan_funcs vulkan_funcs =
+{
+    .p_vkCreateInstance = wayland_vkCreateInstance,
+};
 
 /**********************************************************************
  *           WAYLAND_wine_get_vulkan_driver
-- 
2.36.1

