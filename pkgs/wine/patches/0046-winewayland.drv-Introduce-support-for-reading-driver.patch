From 691d6eaa0f840d0e4bac5c5b87e31c34d6ce3d05 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 24 Sep 2021 11:22:32 +0300
Subject: [PATCH 046/170] winewayland.drv: Introduce support for reading driver
 options from the registry.

Add the infrastructure to read driver options from the registry. Future
commits will add support for specific options.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |  1 +
 dlls/winewayland.drv/options.c         | 90 ++++++++++++++++++++++++++
 dlls/winewayland.drv/registry.c        | 46 +++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  2 +
 dlls/winewayland.drv/waylanddrv_main.c |  2 +
 5 files changed, 141 insertions(+)
 create mode 100644 dlls/winewayland.drv/options.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 2232c7aee9e..5a501e03754 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -11,6 +11,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	options.c \
 	registry.c \
 	unicode.c \
 	wayland.c \
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
new file mode 100644
index 00000000000..19df27644eb
--- /dev/null
+++ b/dlls/winewayland.drv/options.c
@@ -0,0 +1,90 @@
+/*
+ * winewayland.drv options
+ *
+ * Copyright 1998 Patrik Stridvall
+ * Copyright 2000 Alexandre Julliard
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+/* Code to read options from the registry, adapted from the X11 driver */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "winuser.h"
+
+#include <string.h>
+
+/***********************************************************************
+ *		get_config_key
+ *
+ * Get a config key from either the app-specific or the default config
+ */
+static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
+                                   ULONG type, char *buffer, DWORD size)
+{
+    if (appkey && !reg_get_value_a(appkey, name, type, buffer, &size)) return 0;
+    if (defkey && !reg_get_value_a(defkey, name, type, buffer, &size)) return 0;
+    return ERROR_FILE_NOT_FOUND;
+}
+
+/***********************************************************************
+ *		wayland_read_options_from_registry
+ *
+ * Read the Wayland driver options from the registry.
+ */
+void wayland_read_options_from_registry(void)
+{
+    static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    WCHAR *p, *appname;
+    HKEY hkey, appkey = 0;
+    DWORD len;
+
+    /* @@ Wine registry key: HKCU\Software\Wine\Wayland Driver */
+    hkey = reg_open_hkcu_key_a("Software\\Wine\\Wayland Driver");
+
+    /* open the app-specific key */
+    appname = NtCurrentTeb()->Peb->ProcessParameters->ImagePathName.Buffer;
+    if ((p = wcsrchr(appname, '/'))) appname = p + 1;
+    if ((p = wcsrchr(appname, '\\'))) appname = p + 1;
+    len = lstrlenW(appname);
+
+    if (len && len < MAX_PATH)
+    {
+        HKEY tmpkey;
+        WCHAR bufferW[MAX_PATH + 16];
+        int i;
+        for (i = 0; appname[i]; i++) bufferW[i] = RtlDowncaseUnicodeChar(appname[i]);
+        bufferW[i] = 0;
+        appname = bufferW;
+        memcpy(appname + i, waylanddriverW, sizeof(waylanddriverW));
+        /* @@ Wine registry key: HKCU\Software\Wine\AppDefaults\app.exe\Wayland Driver */
+        if ((tmpkey = reg_open_hkcu_key_a("Software\\Wine\\AppDefaults")))
+        {
+            appkey = reg_open_key_w(tmpkey, appname);
+            NtClose(tmpkey);
+        }
+    }
+
+    if (appkey) NtClose(appkey);
+    if (hkey) NtClose(hkey);
+}
diff --git a/dlls/winewayland.drv/registry.c b/dlls/winewayland.drv/registry.c
index 594ba6600fc..66812b5b4f8 100644
--- a/dlls/winewayland.drv/registry.c
+++ b/dlls/winewayland.drv/registry.c
@@ -26,6 +26,8 @@
 
 #include "waylanddrv.h"
 
+#include <stdio.h>
+
 /**********************************************************************
  *          reg_open_key_a
  *
@@ -64,6 +66,50 @@ HKEY reg_open_key_w(HKEY root, const WCHAR *nameW)
     return NtOpenKeyEx(&ret, MAXIMUM_ALLOWED, &attr, 0) ? 0 : ret;
 }
 
+/**********************************************************************
+ *          reg_open_hkcu_key_a
+ *
+ *  Open a registry key under HKCU with the specified ASCII name.
+ */
+HKEY reg_open_hkcu_key_a(const char *name)
+{
+    static HKEY hkcu;
+
+    if (!hkcu)
+    {
+        char buffer[256];
+        DWORD_PTR sid_data[(sizeof(TOKEN_USER) + SECURITY_MAX_SID_SIZE) / sizeof(DWORD_PTR)];
+        DWORD i, len = sizeof(sid_data);
+        SID *sid;
+
+        if (NtQueryInformationToken(GetCurrentThreadEffectiveToken(), TokenUser, sid_data,
+                                    len, &len))
+        {
+            return 0;
+        }
+
+        sid = ((TOKEN_USER *)sid_data)->User.Sid;
+        len = snprintf(buffer, ARRAY_SIZE(buffer), "\\Registry\\User\\S-%u-%u",
+                       sid->Revision,
+                       MAKELONG(MAKEWORD(sid->IdentifierAuthority.Value[5],
+                                         sid->IdentifierAuthority.Value[4]),
+                                MAKEWORD(sid->IdentifierAuthority.Value[3],
+                                         sid->IdentifierAuthority.Value[2])));
+        if (len >= ARRAY_SIZE(buffer)) return 0;
+
+        for (i = 0; i < sid->SubAuthorityCount; i++)
+        {
+            len += snprintf(buffer + len, ARRAY_SIZE(buffer) - len, "-%u",
+                            sid->SubAuthority[i]);
+            if (len >= ARRAY_SIZE(buffer)) return 0;
+        }
+
+        hkcu = reg_open_key_a(NULL, buffer);
+    }
+
+    return reg_open_key_a(hkcu, name);
+}
+
 static DWORD reg_get_value_info(HKEY hkey, const WCHAR *nameW, ULONG type,
                                 KEY_VALUE_PARTIAL_INFORMATION *info,
                                 ULONG info_size)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 52abc780efd..94de6e2db6c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -256,6 +256,7 @@ BOOL wayland_is_process(struct wayland *wayland) DECLSPEC_HIDDEN;
 struct wayland *wayland_process_acquire(void) DECLSPEC_HIDDEN;
 void wayland_process_release(void) DECLSPEC_HIDDEN;
 void wayland_init_display_devices(void) DECLSPEC_HIDDEN;
+void wayland_read_options_from_registry(void) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland mutex
@@ -384,6 +385,7 @@ void wayland_set_cursor_if_current_invalid(HCURSOR hcursor) DECLSPEC_HIDDEN;
 
 HKEY reg_open_key_a(HKEY root, const char *name) DECLSPEC_HIDDEN;
 HKEY reg_open_key_w(HKEY root, const WCHAR *nameW) DECLSPEC_HIDDEN;
+HKEY reg_open_hkcu_key_a(const char *name) DECLSPEC_HIDDEN;
 DWORD reg_get_value_a(HKEY hkey, const char *name, ULONG type, char *buffer,
                       DWORD *buffer_len) DECLSPEC_HIDDEN;
 DWORD reg_get_value_w(HKEY hkey, const WCHAR *nameW, ULONG type, char *buffer,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 05e787656ea..0757a6af4e6 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -154,6 +154,8 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
 
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
+    wayland_read_options_from_registry();
+
     if (!wayland_init_set_cursor()) return STATUS_UNSUCCESSFUL;
 
     if (!wayland_process_init()) return STATUS_UNSUCCESSFUL;
-- 
2.36.1

