From d00c0b96bc5b2efef4119c004f4d5d02e8f823e9 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 16:56:28 +0300
Subject: [PATCH 028/170] winewayland.drv: Add infrastructure for Wayland SHM
 buffers.

Add the infrastructure and functions needed to manage Wayland SHM (i.e.,
software) buffers and their damage tracking.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in             |   1 +
 dlls/winewayland.drv/wayland.c               |   7 +
 dlls/winewayland.drv/wayland_native_buffer.c |  33 +++
 dlls/winewayland.drv/wayland_shm.c           | 219 +++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h            |  30 +++
 5 files changed, 290 insertions(+)
 create mode 100644 dlls/winewayland.drv/wayland_shm.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index e84e8c79f24..8312e3278e8 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -17,6 +17,7 @@ C_SRCS = \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
+	wayland_shm.c \
 	wayland_shmfd.c \
 	waylanddrv_main.c \
 	window.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index c0d108c5d95..059c8c4150e 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -85,6 +85,10 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wayland->wl_compositor =
             wl_registry_bind(registry, id, &wl_compositor_interface, 4);
     }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
 }
 
 static void registry_handle_global_remove(void *data, struct wl_registry *registry,
@@ -200,6 +204,9 @@ void wayland_deinit(struct wayland *wayland)
     wl_list_for_each_safe(output, output_tmp, &wayland->output_list, link)
         wayland_output_destroy(output);
 
+    if (wayland->wl_shm)
+        wl_shm_destroy(wayland->wl_shm);
+
     if (wayland->zxdg_output_manager_v1)
         zxdg_output_manager_v1_destroy(wayland->zxdg_output_manager_v1);
 
diff --git a/dlls/winewayland.drv/wayland_native_buffer.c b/dlls/winewayland.drv/wayland_native_buffer.c
index 4473c3a553f..471c636c04a 100644
--- a/dlls/winewayland.drv/wayland_native_buffer.c
+++ b/dlls/winewayland.drv/wayland_native_buffer.c
@@ -24,8 +24,41 @@
 
 #include "waylanddrv.h"
 
+#include <assert.h>
 #include <unistd.h>
 
+/**********************************************************************
+ *          wayland_native_buffer_init_shm
+ *
+ * Deinitializes a native buffer, releasing any associated resources.
+ */
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format)
+{
+    int stride;
+    off_t size;
+    int fd;
+
+    assert(format == WL_SHM_FORMAT_ARGB8888 || format == WL_SHM_FORMAT_XRGB8888);
+
+    stride = width * 4;
+    size = stride * height;
+
+    fd = wayland_shmfd_create("wayland-shm", size);
+    if (fd < 0) return FALSE;
+
+    native->plane_count = 1;
+    native->fds[0] = fd;
+    native->strides[0] = stride;
+    native->offsets[0] = 0;
+    native->width = width;
+    native->height = height;
+    native->format = format;
+
+    return TRUE;
+}
+
 /**********************************************************************
  *          wayland_native_buffer_deinit
  *
diff --git a/dlls/winewayland.drv/wayland_shm.c b/dlls/winewayland.drv/wayland_shm.c
new file mode 100644
index 00000000000..254f574f33b
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_shm.c
@@ -0,0 +1,219 @@
+/*
+ * Wayland SHM buffers
+ *
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include <errno.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+#include "ntgdi.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static struct wayland_shm_buffer *wayland_shm_buffer_create_from_native(struct wayland *wayland,
+                                                                        struct wayland_native_buffer *native)
+{
+    struct wayland_shm_buffer *shm_buffer;
+    struct wl_shm_pool *pool;
+    int size;
+    void *data;
+
+    shm_buffer = calloc(1, sizeof(*shm_buffer));
+    if (!shm_buffer)
+        goto err;
+
+    wl_list_init(&shm_buffer->link);
+
+    size = native->strides[0] * native->height;
+
+    TRACE("%p %dx%d format=%d size=%d\n",
+          shm_buffer, native->width, native->height, native->format, size);
+
+    if (size == 0)
+        goto err;
+
+    data = mmap(NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, native->fds[0], 0);
+    if (data == MAP_FAILED)
+    {
+        ERR("mmap failed: %s size=%d\n", strerror(errno), size);
+        goto err;
+    }
+
+    pool = wl_shm_create_pool(wayland->wl_shm, native->fds[0], size);
+    shm_buffer->wl_buffer = wl_shm_pool_create_buffer(pool, 0, native->width, native->height,
+                                                      native->strides[0], native->format);
+    wl_shm_pool_destroy(pool);
+
+    shm_buffer->width = native->width;
+    shm_buffer->height = native->height;
+    shm_buffer->stride = native->strides[0];
+    shm_buffer->format = native->format;
+    shm_buffer->map_data = data;
+    shm_buffer->map_size = size;
+    shm_buffer->damage_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+    if (!shm_buffer->damage_region)
+    {
+        ERR("failed to create buffer damage region\n");
+        goto err;
+    }
+
+    TRACE("%p %dx%d size=%d => map=%p\n",
+          shm_buffer, native->width, native->height, size, data);
+
+    return shm_buffer;
+
+err:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    return NULL;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_create
+ *
+ * Creates a SHM buffer with the specified width, height and format.
+ */
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format)
+{
+    struct wayland_native_buffer native;
+    struct wayland_shm_buffer *shm_buffer;
+
+    if (wayland_native_buffer_init_shm(&native, width, height, format))
+    {
+        shm_buffer = wayland_shm_buffer_create_from_native(wayland, &native);
+        wayland_native_buffer_deinit(&native);
+    }
+    else
+    {
+        shm_buffer = NULL;
+    }
+
+    return shm_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_destroy
+ *
+ * Destroys a SHM buffer.
+ */
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    TRACE("%p map=%p\n", shm_buffer, shm_buffer->map_data);
+
+    wl_list_remove(&shm_buffer->link);
+
+    if (shm_buffer->wl_buffer)
+        wl_buffer_destroy(shm_buffer->wl_buffer);
+    if (shm_buffer->map_data)
+        munmap(shm_buffer->map_data, shm_buffer->map_size);
+    if (shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(shm_buffer->damage_region);
+
+    free(shm_buffer);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_steal_wl_buffer_and_destroy
+ *
+ * Steal the wl_buffer from a SHM buffer and destroy the SHM buffer.
+ */
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer)
+{
+    struct wl_buffer *wl_buffer;
+
+    wl_buffer = shm_buffer->wl_buffer;
+    shm_buffer->wl_buffer = NULL;
+
+    wayland_shm_buffer_destroy(shm_buffer);
+
+    return wl_buffer;
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_clear_damage
+ *
+ *  Clears all damage accumulated by a SHM buffer.
+ */
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer)
+{
+    NtGdiSetRectRgn(shm_buffer->damage_region, 0, 0, 0, 0);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_add_damage
+ *
+ *  Adds damage (i.e., a region which needs update) to a SHM buffer.
+ */
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage)
+{
+    NtGdiCombineRgn(shm_buffer->damage_region, shm_buffer->damage_region, damage, RGN_OR);
+}
+
+/**********************************************************************
+ *          wayland_shm_buffer_get_damage_clipped
+ *
+ * Returns the damage region data for this buffer clipped within the
+ * provided clip region (if any).
+ *
+ * The returned RGNDATA* should be freed by the caller using free().
+ */
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip)
+{
+    RGNDATA *data = NULL;
+    DWORD size;
+    HRGN damage_region;
+
+    if (clip)
+    {
+        damage_region = NtGdiCreateRectRgn(0, 0, 0, 0);
+        if (!damage_region) goto err;
+        NtGdiCombineRgn(damage_region, shm_buffer->damage_region, clip, RGN_AND);
+    }
+    else
+    {
+        damage_region = shm_buffer->damage_region;
+    }
+
+    if (!(size = NtGdiGetRegionData(damage_region, 0, NULL))) goto err;
+    if (!(data = malloc(size))) goto err;
+    if (!NtGdiGetRegionData(damage_region, size, data)) goto err;
+
+    if (damage_region != shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(damage_region);
+
+    return data;
+
+err:
+    if (damage_region && damage_region != shm_buffer->damage_region)
+        NtGdiDeleteObjectApp(damage_region);
+    free(data);
+    return NULL;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e7e48dba3a8..58181ae5e0e 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -76,6 +76,7 @@ struct wayland
     struct wl_event_queue *wl_event_queue;
     struct wl_registry *wl_registry;
     struct wl_compositor *wl_compositor;
+    struct wl_shm *wl_shm;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
@@ -118,6 +119,18 @@ struct wayland_native_buffer
     uint32_t format;
 };
 
+struct wayland_shm_buffer
+{
+    struct wl_list link;
+    struct wl_buffer *wl_buffer;
+    int width, height, stride;
+    enum wl_shm_format format;
+    void *map_data;
+    size_t map_size;
+    BOOL busy;
+    HRGN damage_region;
+};
+
 /**********************************************************************
  *          Wayland thread data
  */
@@ -190,8 +203,25 @@ int wayland_dispatch_queue(struct wl_event_queue *queue, int timeout_ms) DECLSPE
  *          Wayland native buffer
  */
 
+BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
+                                    int width, int height,
+                                    enum wl_shm_format format) DECLSPEC_HIDDEN;
 void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland SHM buffer
+ */
+
+struct wayland_shm_buffer *wayland_shm_buffer_create(struct wayland *wayland,
+                                                     int width, int height,
+                                                     enum wl_shm_format format) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+struct wl_buffer *wayland_shm_buffer_steal_wl_buffer_and_destroy(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_clear_damage(struct wayland_shm_buffer *shm_buffer) DECLSPEC_HIDDEN;
+void wayland_shm_buffer_add_damage(struct wayland_shm_buffer *shm_buffer, HRGN damage) DECLSPEC_HIDDEN;
+RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_buffer,
+                                               HRGN clip) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Registry helpers
  */
-- 
2.36.1

