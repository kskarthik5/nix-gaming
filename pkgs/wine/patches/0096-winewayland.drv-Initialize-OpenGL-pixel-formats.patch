From 6f7aac9841ef5324bb20c4a614244fe7bbb48db2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 12:26:45 +0300
Subject: [PATCH 096/170] winewayland.drv: Initialize OpenGL pixel formats.

Create an array of supported pixel formats, each backed by an EGLConfig.
We only expose formats that the compositor can accept.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c         | 84 +++++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_dmabuf.c |  9 ++-
 dlls/winewayland.drv/waylanddrv.h     |  3 +
 3 files changed, 94 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index b4dabde0c4a..d9e53ca2f75 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -47,6 +47,13 @@ WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 #include <EGL/egl.h>
 #include <assert.h>
 #include <dlfcn.h>
+#include <stdlib.h>
+
+struct wgl_pixel_format
+{
+    EGLConfig config;
+    EGLint native_visual_id;
+};
 
 static void *egl_handle;
 static void *opengl_handle;
@@ -54,8 +61,12 @@ static EGLDisplay egl_display;
 static EGLint egl_version[2];
 static struct opengl_funcs egl_funcs;
 static char wgl_extensions[4096];
+static struct wgl_pixel_format *pixel_formats;
+static int nb_pixel_formats, nb_onscreen_formats;
 
 #define DECL_FUNCPTR(f) static __typeof__(f) * p_##f = NULL
+DECL_FUNCPTR(eglGetConfigAttrib);
+DECL_FUNCPTR(eglGetConfigs);
 DECL_FUNCPTR(eglGetDisplay);
 DECL_FUNCPTR(eglGetProcAddress);
 DECL_FUNCPTR(eglInitialize);
@@ -391,6 +402,75 @@ static void init_extensions(void)
 #undef LOAD_FUNCPTR
 }
 
+static BOOL init_pixel_formats(void)
+{
+    EGLint count, i, pass;
+    EGLConfig *egl_configs;
+    struct wayland_dmabuf *dmabuf;
+
+    p_eglGetConfigs(egl_display, NULL, 0, &count);
+    egl_configs = malloc(count * sizeof(*egl_configs));
+    pixel_formats = malloc(count * sizeof(*pixel_formats));
+    p_eglGetConfigs(egl_display, egl_configs, count, &count);
+    if (!count || !egl_configs || !pixel_formats)
+    {
+        free(egl_configs);
+        free(pixel_formats);
+        ERR("eglGetConfigs returned no configs\n");
+        return FALSE;
+    }
+
+    dmabuf = &wayland_process_acquire()->dmabuf;
+
+    /* Use two passes: the first pass adds the onscreen formats to the format list,
+     * the second offscreen ones. */
+    for (pass = 0; pass < 2; pass++)
+    {
+        for (i = 0; i < count; i++)
+        {
+            EGLint id, type, visual_id, native, render, color, r, g, b, d, s;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_SURFACE_TYPE, &type);
+            if (!(type & EGL_WINDOW_BIT) == !pass) continue;
+
+            /* Ignore formats not supported by the compositor. */
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_VISUAL_ID, &visual_id);
+            if (wayland_dmabuf_has_format_list(dmabuf) &&
+                !wayland_dmabuf_find_format(dmabuf, visual_id))
+                continue;
+
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RENDERABLE_TYPE, &render);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_CONFIG_ID, &id);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_NATIVE_RENDERABLE, &native);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_COLOR_BUFFER_TYPE, &color);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_RED_SIZE, &r);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_GREEN_SIZE, &g);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_BLUE_SIZE, &b);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_DEPTH_SIZE, &d);
+            p_eglGetConfigAttrib(egl_display, egl_configs[i], EGL_STENCIL_SIZE, &s);
+
+            /* Some drivers expose 10 bit components which are not typically what
+             * applications want. */
+            if (r > 8 || g > 8 || b > 8) continue;
+
+            pixel_formats[nb_pixel_formats].config = egl_configs[i];
+            pixel_formats[nb_pixel_formats].native_visual_id = visual_id;
+            nb_pixel_formats++;
+            TRACE("%u: config %u id %u type %x visual %u native %u render %x "
+                  "colortype %u rgb %u,%u,%u depth %u stencil %u\n",
+                   nb_pixel_formats, i, id, type, visual_id, native, render,
+                   color, r, g, b, d, s);
+        }
+        if (pass == 0) nb_onscreen_formats = nb_pixel_formats;
+    }
+
+    wayland_process_release();
+
+    free(egl_configs);
+
+    return TRUE;
+}
+
 static BOOL egl_init(void)
 {
     static int retval = -1;
@@ -424,6 +504,8 @@ static BOOL egl_init(void)
         if (!(p_##func = dlsym(egl_handle, #func))) \
         { ERR("can't find symbol %s\n", #func); return FALSE; }    \
     } while(0)
+    LOAD_FUNCPTR(eglGetConfigAttrib);
+    LOAD_FUNCPTR(eglGetConfigs);
     LOAD_FUNCPTR(eglGetDisplay);
     LOAD_FUNCPTR(eglGetProcAddress);
     LOAD_FUNCPTR(eglInitialize);
@@ -436,6 +518,8 @@ static BOOL egl_init(void)
         return FALSE;
     TRACE("display %p version %u.%u\n", egl_display, egl_version[0], egl_version[1]);
 
+    if (!init_pixel_formats()) return FALSE;
+
     init_extensions();
     retval = 1;
     return TRUE;
diff --git a/dlls/winewayland.drv/wayland_dmabuf.c b/dlls/winewayland.drv/wayland_dmabuf.c
index 016b447b24a..16a90bdf317 100644
--- a/dlls/winewayland.drv/wayland_dmabuf.c
+++ b/dlls/winewayland.drv/wayland_dmabuf.c
@@ -32,8 +32,13 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
-static struct wayland_dmabuf_format *wayland_dmabuf_find_format(struct wayland_dmabuf *dmabuf,
-                                                                uint32_t format)
+BOOL wayland_dmabuf_has_format_list(struct wayland_dmabuf *dmabuf)
+{
+    return !wl_list_empty(&dmabuf->formats);
+}
+
+struct wayland_dmabuf_format *wayland_dmabuf_find_format(struct wayland_dmabuf *dmabuf,
+                                                         uint32_t format)
 {
     struct wayland_dmabuf_format *dmabuf_format;
 
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 6beebb3b0ce..723142e861b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -462,6 +462,9 @@ RGNDATA *wayland_shm_buffer_get_damage_clipped(struct wayland_shm_buffer *shm_bu
 void wayland_dmabuf_init(struct wayland_dmabuf *dmabuf,
                          struct zwp_linux_dmabuf_v1 *zwp_linux_dmabuf_v1) DECLSPEC_HIDDEN;
 void wayland_dmabuf_deinit(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+BOOL wayland_dmabuf_has_format_list(struct wayland_dmabuf *dmabuf) DECLSPEC_HIDDEN;
+struct wayland_dmabuf_format *wayland_dmabuf_find_format(struct wayland_dmabuf *dmabuf,
+                                                         uint32_t format) DECLSPEC_HIDDEN;
 struct wayland_dmabuf_buffer *wayland_dmabuf_buffer_create_from_native(struct wayland *wayland,
                                                                        struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 void wayland_dmabuf_buffer_destroy(struct wayland_dmabuf_buffer *dmabuf_buffer) DECLSPEC_HIDDEN;
-- 
2.36.1

