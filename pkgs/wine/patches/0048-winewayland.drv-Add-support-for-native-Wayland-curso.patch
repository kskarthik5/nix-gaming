From e25900ee0809b900ffb27e05a566fe7b51f3776a Mon Sep 17 00:00:00 2001
From: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Date: Tue, 8 Mar 2022 14:22:59 -0300
Subject: [PATCH 048/170] winewayland.drv: Add support for native Wayland
 cursors.

Until now, we were using the cursors provided by Wine. Add native
Wayland cursor support, respecting the theme being used in the system.

The "UseSystemCursors" driver option controls whether to use the
native Wayland cursors (the default) or use the Wine provided
cursors.

Signed-off-by: Leandro Ribeiro <leandro.ribeiro@collabora.com>
Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                             |  85 ++++++-
 configure.ac                          |   7 +-
 dlls/winewayland.drv/Makefile.in      |   6 +-
 dlls/winewayland.drv/dllmain.c        |   8 +
 dlls/winewayland.drv/options.c        |  13 +
 dlls/winewayland.drv/unixlib.h        |  12 +-
 dlls/winewayland.drv/wayland.c        |  18 +-
 dlls/winewayland.drv/wayland_cursor.c | 337 +++++++++++++++++++++++---
 dlls/winewayland.drv/waylanddrv.h     |   4 +
 include/config.h.in                   |   3 +
 10 files changed, 453 insertions(+), 40 deletions(-)

diff --git a/configure b/configure
index 849e56b374f..6dd1711bbc9 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,8 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+WAYLAND_CURSOR_LIBS
+WAYLAND_CURSOR_CFLAGS
 WAYLAND_SCANNER
 WAYLAND_PROTOCOLS_DATADIR
 WAYLAND_PROTOCOLS_LIBS
@@ -1710,6 +1712,8 @@ WAYLAND_CLIENT_CFLAGS
 WAYLAND_CLIENT_LIBS
 WAYLAND_PROTOCOLS_CFLAGS
 WAYLAND_PROTOCOLS_LIBS
+WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2515,6 +2519,10 @@ Some influential environment variables:
               C compiler flags for wayland-protocols, overriding pkg-config
   WAYLAND_PROTOCOLS_LIBS
               Linker flags for wayland-protocols, overriding pkg-config
+  WAYLAND_CURSOR_CFLAGS
+              C compiler flags for wayland-cursor, overriding pkg-config
+  WAYLAND_CURSOR_LIBS
+              Linker flags for wayland-cursor, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -15918,10 +15926,83 @@ printf "%s\n" "no" >&6; }
 fi
 
 
+    if ${WAYLAND_CURSOR_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_CFLAGS=`$PKG_CONFIG --cflags wayland-cursor 2>/dev/null`
+fi
+fi
+
+if ${WAYLAND_CURSOR_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  WAYLAND_CURSOR_LIBS=`$PKG_CONFIG --libs wayland-cursor 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor cflags: $WAYLAND_CURSOR_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: wayland-cursor libs: $WAYLAND_CURSOR_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $WAYLAND_CURSOR_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "wayland-cursor.h" "ac_cv_header_wayland_cursor_h" "$ac_includes_default"
+if test "x$ac_cv_header_wayland_cursor_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_WAYLAND_CURSOR_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for wl_cursor_theme_load in -lwayland-cursor" >&5
+printf %s "checking for wl_cursor_theme_load in -lwayland-cursor... " >&6; }
+if test ${ac_cv_lib_wayland_cursor_wl_cursor_theme_load+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lwayland-cursor $WAYLAND_CURSOR_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char wl_cursor_theme_load ();
+int
+main (void)
+{
+return wl_cursor_theme_load ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=yes
+else $as_nop
+  ac_cv_lib_wayland_cursor_wl_cursor_theme_load=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&5
+printf "%s\n" "$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" >&6; }
+if test "x$ac_cv_lib_wayland_cursor_wl_cursor_theme_load" = xyes
+then :
+  :
+else $as_nop
+  WAYLAND_CURSOR_LIBS=""
+fi
+
+CPPFLAGS=$ac_save_CPPFLAGS
+
 fi
 if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
-                           test -z "$WAYLAND_SCANNER"
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS"
 then :
   case "x$with_wayland" in
   x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
@@ -23452,6 +23533,8 @@ WAYLAND_PROTOCOLS_CFLAGS = $WAYLAND_PROTOCOLS_CFLAGS
 WAYLAND_PROTOCOLS_LIBS = $WAYLAND_PROTOCOLS_LIBS
 WAYLAND_PROTOCOLS_DATADIR = $WAYLAND_PROTOCOLS_DATADIR
 WAYLAND_SCANNER = $WAYLAND_SCANNER
+WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
+WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index 1ce656f5f39..668321e434f 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1372,10 +1372,15 @@ then
                    `$PKG_CONFIG --atleast-version=1.14 wayland-protocols && $PKG_CONFIG --variable=pkgdatadir wayland-protocols`)])
     AC_PATH_PROG(WAYLAND_SCANNER,wayland-scanner,
                  [`$PKG_CONFIG --variable=wayland_scanner wayland-scanner`])
+    WINE_PACKAGE_FLAGS(WAYLAND_CURSOR,[wayland-cursor],,,,
+        [AC_CHECK_HEADERS([wayland-cursor.h])
+         AC_CHECK_LIB(wayland-cursor,wl_cursor_theme_load,[:],
+                      [WAYLAND_CURSOR_LIBS=""],[$WAYLAND_CURSOR_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
-                           test -z "$WAYLAND_SCANNER"],
+                           test -z "$WAYLAND_SCANNER" ||
+                           test -z "$WAYLAND_CURSOR_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 5a501e03754..f7385b682ba 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -1,8 +1,10 @@
 EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
-EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS)
-EXTRALIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(PTHREAD_LIBS)
+IMPORTS = user32
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS)
+EXTRALIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
+             $(PTHREAD_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
diff --git a/dlls/winewayland.drv/dllmain.c b/dlls/winewayland.drv/dllmain.c
index 83d42effffe..e8f5d0ec100 100644
--- a/dlls/winewayland.drv/dllmain.c
+++ b/dlls/winewayland.drv/dllmain.c
@@ -23,9 +23,17 @@
 static unixlib_handle_t waylanddrv_handle;
 NTSTATUS (CDECL *waylanddrv_unix_call)(enum waylanddrv_unix_func func, void *params);
 
+static NTSTATUS WINAPI waylanddrv_client_load_cursor(void *arg, ULONG size)
+{
+    struct waylanddrv_client_load_cursor_params *p = arg;
+
+    return HandleToULong(LoadCursorW(NULL, UIntToPtr(p->name)));
+}
+
 typedef NTSTATUS (WINAPI *kernel_callback)(void *params, ULONG size);
 static const kernel_callback kernel_callbacks[] =
 {
+    waylanddrv_client_load_cursor,
 };
 
 C_ASSERT(NtUserDriverCallbackFirst + ARRAYSIZE(kernel_callbacks) == waylanddrv_client_func_last);
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
index 19df27644eb..7f0b4b31e2c 100644
--- a/dlls/winewayland.drv/options.c
+++ b/dlls/winewayland.drv/options.c
@@ -34,6 +34,15 @@
 
 #include <string.h>
 
+#define IS_OPTION_TRUE(ch) \
+    ((ch) == 'y' || (ch) == 'Y' || (ch) == 't' || (ch) == 'T' || (ch) == '1')
+
+/***********************************************************************
+ *              Config options
+ */
+
+BOOL option_use_system_cursors = TRUE;
+
 /***********************************************************************
  *		get_config_key
  *
@@ -55,6 +64,7 @@ static inline DWORD get_config_key(HKEY defkey, HKEY appkey, const char *name,
 void wayland_read_options_from_registry(void)
 {
     static const WCHAR waylanddriverW[] = {'\\','W','a','y','l','a','n','d',' ','D','r','i','v','e','r',0};
+    char buffer[64];
     WCHAR *p, *appname;
     HKEY hkey, appkey = 0;
     DWORD len;
@@ -85,6 +95,9 @@ void wayland_read_options_from_registry(void)
         }
     }
 
+    if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
+        option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
+
     if (appkey) NtClose(appkey);
     if (hkey) NtClose(hkey);
 }
diff --git a/dlls/winewayland.drv/unixlib.h b/dlls/winewayland.drv/unixlib.h
index a3ac9efe7ee..50738328c77 100644
--- a/dlls/winewayland.drv/unixlib.h
+++ b/dlls/winewayland.drv/unixlib.h
@@ -23,6 +23,10 @@
 #include "ntuser.h"
 #include "wine/unixlib.h"
 
+/* A pointer to memory that is guaranteed to be usable by both 32-bit and
+ * 64-bit processes. */
+typedef UINT PTR32;
+
 enum waylanddrv_unix_func
 {
     waylanddrv_unix_func_init,
@@ -38,9 +42,15 @@ struct waylanddrv_unix_init_params
 /* driver client callbacks exposed with KernelCallbackTable interface */
 enum waylanddrv_client_func
 {
-    waylanddrv_client_func_last = NtUserDriverCallbackFirst
+    waylanddrv_client_func_load_cursor = NtUserDriverCallbackFirst,
+    waylanddrv_client_func_last,
 };
 
 C_ASSERT(waylanddrv_client_func_last <= NtUserDriverCallbackLast + 1);
 
+struct waylanddrv_client_load_cursor_params
+{
+    PTR32 name;
+};
+
 #endif /* __WINE_WAYLANDDRV_UNIXLIB_H */
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 97319cbc6da..ad79202dd4f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -121,8 +121,13 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
         wl_list_for_each(output, &wayland->output_list, link)
             wayland_output_use_xdg_extension(output);
     }
+    else if (strcmp(interface, "wl_shm") == 0)
+    {
+        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
+    }
 
-    /* The per-process wayland instance only handles output related globals. */
+    /* The per-process wayland instance only handles output related
+     * and wl_shm globals. */
     if (wayland_is_process(wayland)) return;
 
     if (strcmp(interface, "wl_compositor") == 0)
@@ -144,10 +149,6 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
                              version < 2 ? version : 2);
         xdg_wm_base_add_listener(wayland->xdg_wm_base, &xdg_wm_base_listener, wayland);
     }
-    else if (strcmp(interface, "wl_shm") == 0)
-    {
-        wayland->wl_shm = wl_registry_bind(registry, id, &wl_shm_interface, 1);
-    }
     else if (strcmp(interface, "wl_seat") == 0)
     {
         wayland->wl_seat = wl_registry_bind(registry, id, &wl_seat_interface,
@@ -242,7 +243,12 @@ BOOL wayland_init(struct wayland *wayland)
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
     wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
 
-    if (!wayland_is_process(wayland))
+    if (wayland_is_process(wayland))
+    {
+        if (option_use_system_cursors)
+            wayland_cursor_theme_init(wayland);
+    }
+    else
     {
         /* Thread wayland instances have notification pipes to inform them when
          * there might be new events in their queues. The read part of the pipe
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index 5dab96331fe..c2998a5ddf2 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -41,9 +41,140 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static struct wl_cursor_theme *cursor_theme = NULL;
+
 static HCURSOR last_cursor;
 static HCURSOR invalid_cursor;
 
+/* Mapping between Windows cursors and native Wayland cursors
+ *
+ * Note that we have multiple possible names for each Wayland cursor. This
+ * happens because the names for each cursor may vary across different themes.
+ *
+ * This table was created based on the docs below.
+ *
+ * https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-loadcursora
+ * https://bugs.kde.org/attachment.cgi?id=67313
+ */
+static const char *idc_appstarting[] = {"half-busy", "progress", "left_ptr_watch",
+                                        "00000000000000020006000e7e9ffc3f",
+                                        "08e8e1c95fe2fc01f976f1e063a24ccd",
+                                        "3ecb610c1bf2410f44200f48c40d3599",
+                                        "9116a3ea924ed2162ecab71ba103b17f"};
+static const char *idc_arrow[] = {"default", "left_ptr",
+                                  "top_left_arrow", "left-arrow"};
+static const char *idc_cross[] = {"crosshair"};
+static const char *idc_hand[] = {"pointing_hand", "pointer", "hand", "hand2"};
+static const char *idc_help[] = {"help", "question_arrow", "whats_this",
+                                 "5c6cd98b3f3ebcb1f9c7f1c204630408",
+                                 "d9ce0ab605698f320427677b458ad60b"};
+static const char *idc_ibeam[] = {"text", "ibeam", "xterm"};
+static const char *idc_icon[] = {"icon"};
+static const char *idc_no[] = {"forbidden", "not-allowed"};
+static const char *idc_pen[] = {"pencil"};
+static const char *idc_sizeall[] = {"size_all"};
+static const char *idc_sizenesw[] = {"nesw-resize", "size_bdiag",
+                                     "50585d75b494802d0151028115016902",
+                                     "fcf1c3c7cd4491d801f1e1c78f100000"};
+static const char *idc_sizens[] = {"ns-resize", "size_ver", "v_double_arrow",
+                                   "00008160000006810000408080010102"};
+static const char *idc_sizenwse[] = {"nwse-resize", "size_fdiag",
+                                     "38c5dff7c7b8962045400281044508d2",
+                                     "c7088f0f3e6c8088236ef8e1e3e70000"};
+static const char *idc_sizewe[] = {"ew-resize", "size_hor", "h_double_arrow",
+                                   "028006030e0e7ebffc7f7070c0600140"};
+static const char *idc_uparrow[] = {"up_arrow"};
+static const char *idc_wait[] = {"wait", "watch",
+                                 "0426c94ea35c87780ff01dc239897213"};
+
+static struct wl_cursor *_wl_cursor_from_wine_cursor(struct wl_cursor_theme *wl_cursor_theme,
+                                                     unsigned long int wine_cursor_enum)
+{
+    unsigned int i, count;
+    static const char **cursors;
+    struct wl_cursor *cursor;
+
+    switch(wine_cursor_enum)
+    {
+        case IDC_APPSTARTING:
+            cursors = idc_appstarting;
+            count = ARRAY_SIZE(idc_appstarting);
+            break;
+        case IDC_ARROW:
+            cursors = idc_arrow;
+            count = ARRAY_SIZE(idc_arrow);
+            break;
+        case IDC_CROSS:
+            cursors = idc_cross;
+            count = ARRAY_SIZE(idc_cross);
+            break;
+        case IDC_HAND:
+            cursors = idc_hand;
+            count = ARRAY_SIZE(idc_hand);
+            break;
+        case IDC_HELP:
+            cursors = idc_help;
+            count = ARRAY_SIZE(idc_help);
+            break;
+        case IDC_IBEAM:
+            cursors = idc_ibeam;
+            count = ARRAY_SIZE(idc_ibeam);
+            break;
+        case IDC_ICON:
+            cursors = idc_icon;
+            count = ARRAY_SIZE(idc_icon);
+            break;
+        case IDC_NO:
+            cursors = idc_no;
+            count = ARRAY_SIZE(idc_no);
+            break;
+        case IDC_PEN:
+            cursors = idc_pen;
+            count = ARRAY_SIZE(idc_pen);
+            break;
+        case IDC_SIZE:
+        case IDC_SIZEALL:
+            cursors = idc_sizeall;
+            count = ARRAY_SIZE(idc_sizeall);
+            break;
+        case IDC_SIZENESW:
+            cursors = idc_sizenesw;
+            count = ARRAY_SIZE(idc_sizenesw);
+            break;
+        case IDC_SIZENS:
+            cursors = idc_sizens;
+            count = ARRAY_SIZE(idc_sizens);
+            break;
+        case IDC_SIZENWSE:
+            cursors = idc_sizenwse;
+            count = ARRAY_SIZE(idc_sizenwse);
+            break;
+        case IDC_SIZEWE:
+            cursors = idc_sizewe;
+            count = ARRAY_SIZE(idc_sizewe);
+            break;
+        case IDC_UPARROW:
+            cursors = idc_uparrow;
+            count = ARRAY_SIZE(idc_uparrow);
+            break;
+        case IDC_WAIT:
+            cursors = idc_wait;
+            count = ARRAY_SIZE(idc_wait);
+            break;
+        default:
+            return NULL;
+    }
+
+    for (i = 0; i < count; i++)
+    {
+        cursor = wl_cursor_theme_get_cursor(wl_cursor_theme, cursors[i]);
+        if (cursor)
+            return cursor;
+    }
+
+    return NULL;
+}
+
 /***********************************************************************
  *           get_icon_info
  *
@@ -182,58 +313,200 @@ failed:
     return NULL;
 }
 
-static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
-                                                        HCURSOR handle)
+/***********************************************************************
+ *           get_wine_cursor_size
+ *
+ * We use the Wine cursor IDC_ARROW to compute the size that we should use in
+ * the Wayland native cursors. The bitmap usually does not have the same
+ * dimensions of the icon, as it uses a margin. So we take the IDC_ARROW and
+ * compute its height.
+ */
+static int get_wine_cursor_size(struct wayland *wayland)
 {
+    HCURSOR handle = NULL;
     ICONINFOEXW info = { 0 };
-    struct wayland_cursor *wayland_cursor = NULL;
     struct wayland_shm_buffer *shm_buffer = NULL;
+    unsigned int *pixels, *row, p, x, y;
+    int first_non_empty_line = -1, last_non_empty_line = -1;
+    struct waylanddrv_client_load_cursor_params params;
 
-    if (!handle) return NULL;
-
-    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
-    if (!wayland_cursor) goto out;
+    params.name = (PTR32)IDC_ARROW;
+    handle = ULongToHandle(WAYLANDDRV_CLIENT_CALL(load_cursor, &params, sizeof(params)));
+    if (!handle)
+        goto out;
 
-    if (!get_icon_info(handle, &info)) goto out;
+    if (!get_icon_info(handle, &info))
+        goto out;
 
     if (info.hbmColor)
     {
         HDC hdc = NtGdiCreateCompatibleDC(0);
-        shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+        shm_buffer = create_color_cursor_buffer(wayland, hdc,
                                                 info.hbmColor, info.hbmMask);
         NtGdiDeleteObjectApp(hdc);
     }
     else
     {
-        shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+        shm_buffer = create_mono_cursor_buffer(wayland, info.hbmMask);
     }
 
-    if (!shm_buffer) goto out;
+    if (!shm_buffer)
+        goto out;
 
-    wayland_cursor->width = shm_buffer->width;
-    wayland_cursor->height = shm_buffer->height;
-    wayland_cursor->wl_buffer =
-        wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+    pixels = (unsigned int *) shm_buffer->map_data;
 
-    /* make sure hotspot is valid */
-    if (info.xHotspot >= wayland_cursor->width ||
-        info.yHotspot >= wayland_cursor->height)
+    /* Compute the height of the IDC_ARROW */
+    for (y = 0; y < shm_buffer->height; y++)
     {
-        info.xHotspot = wayland_cursor->width / 2;
-        info.yHotspot = wayland_cursor->height / 2;
+        row = (unsigned int *)((unsigned char *)pixels + y * shm_buffer->stride);
+        for (x = 0; x < shm_buffer->width; x++)
+        {
+            p = row[x];
+            /* alpha 0 means fully transparent, so no content in the
+             * pixel - any other pixel we consider content */
+            if ((p & 0xff000000) == 0)
+                continue;
+            /* it's the first time that we find a content pixel, so we set
+             * the first non empty line variable accordingly */
+            if (first_non_empty_line == -1)
+                first_non_empty_line = y;
+            /* we found a content pixel in a line, so update the latest line
+             * that does have content */
+            last_non_empty_line = y;
+            /* we don't care about the other pixels of the line if we have
+             * already found a content pixel on it */
+            break;
+        }
     }
 
-    if (pointer->focused_surface)
+out:
+    if (handle) NtUserDestroyCursor(handle, 0);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (shm_buffer) wayland_shm_buffer_destroy(shm_buffer);
+
+    if (first_non_empty_line == -1 || last_non_empty_line == -1)
+        return -1;
+
+    return (last_non_empty_line - first_non_empty_line + 1);
+}
+
+void wayland_cursor_theme_init(struct wayland *wayland)
+{
+    char *theme;
+    int size;
+
+    if (!wayland->wl_shm)
+        return;
+
+    size = get_wine_cursor_size(wayland);
+    if (size <= 0)
+       return;
+
+    /* Some compositors set this env var, others don't. But that's fine, if we
+     * call wl_cursor_theme_load() with theme == NULL it will fallback and try
+     * to load the default system theme. */
+    theme = getenv("XCURSOR_THEME");
+
+    cursor_theme = wl_cursor_theme_load(theme, size, wayland->wl_shm);
+}
+
+static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
+                                                        HCURSOR handle)
+{
+    ICONINFOEXW info = { 0 };
+    struct wayland_cursor *wayland_cursor = NULL;
+    struct wayland_shm_buffer *shm_buffer = NULL;
+
+    if (!handle) return NULL;
+
+    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto out;
+
+    if (!get_icon_info(handle, &info)) goto out;
+
+    /* First try to get the native Wayland cursor (if the config option is set
+     * and the per-process Wayland instance was able to load the theme) */
+    if (option_use_system_cursors && cursor_theme)
     {
-        wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
-                                                 info.xHotspot, info.yHotspot,
-                                                 &wayland_cursor->hotspot_x,
-                                                 &wayland_cursor->hotspot_y);
+        struct wl_cursor_image *wl_cursor_image;
+        struct wl_cursor *wl_cursor;
+
+        wayland_cursor->owns_wl_buffer = FALSE;
+        wl_cursor = _wl_cursor_from_wine_cursor(cursor_theme, MAKEINTRESOURCE(info.wResID));
+        if (wl_cursor && wl_cursor->image_count > 0)
+        {
+            /* TODO: add animated cursor support
+             * cursor->images[i] for i > 0 is only used by animations. */
+            wl_cursor_image = wl_cursor->images[0];
+            wayland_cursor->wl_buffer = wl_cursor_image_get_buffer(wl_cursor_image);
+            if (wayland_cursor->wl_buffer)
+            {
+                wayland_cursor->width = wl_cursor_image->width;
+                wayland_cursor->height = wl_cursor_image->height;
+
+                if (pointer->focused_surface)
+                {
+                    wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                             wl_cursor_image->hotspot_x,
+                                                             wl_cursor_image->hotspot_y,
+                                                             &wayland_cursor->hotspot_x,
+                                                             &wayland_cursor->hotspot_y);
+                }
+                else
+                {
+                    wayland_cursor->hotspot_x = wl_cursor_image->hotspot_x;
+                    wayland_cursor->hotspot_y = wl_cursor_image->hotspot_y;
+                }
+            }
+        }
     }
-    else
+
+    /* If we couldn't get native Wayland cursor (or we didn't even try,
+     * because the config to use it was not set), we copy the Wine cursor
+     * content to a wl_buffer */
+    if (!wayland_cursor->wl_buffer)
     {
-        wayland_cursor->hotspot_x = info.xHotspot;
-        wayland_cursor->hotspot_y = info.yHotspot;
+        wayland_cursor->owns_wl_buffer = TRUE;
+        if (info.hbmColor)
+        {
+            HDC hdc = NtGdiCreateCompatibleDC(0);
+            shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+                                                    info.hbmColor, info.hbmMask);
+            NtGdiDeleteObjectApp(hdc);
+        }
+        else
+        {
+            shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+        }
+
+        if (!shm_buffer) goto out;
+
+        wayland_cursor->width = shm_buffer->width;
+        wayland_cursor->height = shm_buffer->height;
+        wayland_cursor->wl_buffer =
+            wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+
+        /* make sure hotspot is valid */
+        if (info.xHotspot >= wayland_cursor->width ||
+            info.yHotspot >= wayland_cursor->height)
+        {
+            info.xHotspot = wayland_cursor->width / 2;
+            info.yHotspot = wayland_cursor->height / 2;
+        }
+
+        if (pointer->focused_surface)
+        {
+            wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                    info.xHotspot, info.yHotspot,
+                                                    &wayland_cursor->hotspot_x,
+                                                    &wayland_cursor->hotspot_y);
+        }
+        else
+        {
+            wayland_cursor->hotspot_x = info.xHotspot;
+            wayland_cursor->hotspot_y = info.yHotspot;
+        }
     }
 
 out:
@@ -258,7 +531,13 @@ void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
         return;
 
     if (wayland_cursor->wl_buffer)
-        wl_buffer_destroy(wayland_cursor->wl_buffer);
+    {
+        /* When using Wayland native cursors, we get the cursor wl_buffer from
+         * using wl_cursor_image_get_buffer(). In such case, the compositor owns
+         * the wl_buffer instead of us. So we should not destroy it. */
+        if (wayland_cursor->owns_wl_buffer)
+            wl_buffer_destroy(wayland_cursor->wl_buffer);
+    }
 
     free(wayland_cursor);
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9c054f10324..98eb41eb9ec 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -28,6 +28,7 @@
 #include <pthread.h>
 #include <stdarg.h>
 #include <wayland-client.h>
+#include <wayland-cursor.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -48,6 +49,7 @@
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
 extern NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,
                                                     BOOLEAN,const LARGE_INTEGER*) DECLSPEC_HIDDEN;
+extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
 
 /**********************************************************************
   *          Internal messages and data
@@ -92,6 +94,7 @@ struct wayland_mutex
 
 struct wayland_cursor
 {
+    BOOL owns_wl_buffer;
     struct wl_buffer *wl_buffer;
     int width;
     int height;
@@ -375,6 +378,7 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
                           struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
 void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
 void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor) DECLSPEC_HIDDEN;
+void wayland_cursor_theme_init(struct wayland *wayland) DECLSPEC_HIDDEN;
 void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
                                               HCURSOR handle) DECLSPEC_HIDDEN;
 BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
diff --git a/include/config.h.in b/include/config.h.in
index e06f2b26cbe..04896af480e 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -703,6 +703,9 @@
 /* Define to 1 if you have the <wayland-client.h> header file. */
 #undef HAVE_WAYLAND_CLIENT_H
 
+/* Define to 1 if you have the <wayland-cursor.h> header file. */
+#undef HAVE_WAYLAND_CURSOR_H
+
 /* Define to 1 if you have the <X11/extensions/shape.h> header file. */
 #undef HAVE_X11_EXTENSIONS_SHAPE_H
 
-- 
2.36.1

