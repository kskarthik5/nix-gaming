From 87d4b09a8ca6dc7dffbe719ba4b8c54492d84c4a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Fri, 10 Sep 2021 18:40:24 +0300
Subject: [PATCH 075/170] winewayland.drv: Handle Wayland surface output
 positioning.

Track the output(s) a Wayland surface is visible in, to allow us to
update the position of the associated window in the Windows virtual
screen space.

We always place windows at the top-left origin of their main output.
The main output is updated to be the leftmost output a surface has
entered. Support for more intuitive handling of windows with RTL layouts
remains to be done.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland.c         |   8 ++
 dlls/winewayland.drv/wayland_surface.c | 153 ++++++++++++++++++++++++-
 dlls/winewayland.drv/waylanddrv.h      |  11 ++
 dlls/winewayland.drv/window.c          |  87 ++++++++++++--
 4 files changed, 251 insertions(+), 8 deletions(-)

diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index fb8cb2662f6..1997080ae42 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -178,7 +178,15 @@ static void registry_handle_global_remove(void *data, struct wl_registry *regist
     {
         if (output->global_id == id)
         {
+            struct wayland_surface *surface;
+
             TRACE("removing output->name=%s\n", output->name);
+
+            /* Remove the output from toplevels, as some compositors don't send
+             * a leave event if the output is disconnected. */
+            wl_list_for_each(surface, &wayland->toplevel_list, link)
+                wayland_surface_leave_output(surface, output);
+
             wayland_output_destroy(output);
             if (wayland_is_process(wayland))
                 wayland_init_display_devices();
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 40d17e80297..ebc82848d34 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -33,6 +33,9 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output);
+
 static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
                                          uint32_t serial)
 {
@@ -134,6 +137,72 @@ static const struct xdg_toplevel_listener xdg_toplevel_listener = {
     handle_xdg_toplevel_close,
 };
 
+static struct wayland_output *wayland_surface_get_origin_output(
+        struct wayland_surface *surface)
+{
+    struct wayland_output_ref *ref;
+    struct wayland_output *leftmost = NULL;
+
+    /* The leftmost entered output is the origin.
+     * TODO: Consider Right-To-Left setups. */
+    wl_list_for_each(ref, &surface->output_ref_list, link)
+    {
+        if (!leftmost || ref->output->x < leftmost->x)
+            leftmost = ref->output;
+    }
+
+    return leftmost;
+}
+
+static void handle_wl_surface_enter(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+    struct wayland_output_ref *ref;
+    struct wayland_output *origin;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    ref = calloc(1, sizeof(*ref));
+    if (!ref) { ERR("memory allocation failed"); return; }
+    ref->output = output;
+    wl_list_insert(&surface->output_ref_list, &ref->link);
+
+    origin = wayland_surface_get_origin_output(surface);
+    wayland_surface_set_main_output(surface, origin);
+}
+
+static void handle_wl_surface_leave(void *data,
+                                    struct wl_surface *wl_surface,
+                                    struct wl_output *wl_output)
+{
+    struct wayland_surface *surface = data;
+    struct wayland_output *output =
+        wl_output ? wl_output_get_user_data(wl_output) : NULL;
+
+    /* We want enter/leave events only for toplevels */
+    if (!surface->xdg_toplevel) return;
+
+    if (!output || output->wayland != surface->wayland) return;
+
+    TRACE("hwnd=%p output->name=%s\n", surface->hwnd, output->name);
+
+    wayland_surface_leave_output(surface, output);
+}
+
+static const struct wl_surface_listener wl_surface_listener = {
+    handle_wl_surface_enter,
+    handle_wl_surface_leave,
+};
+
 /**********************************************************************
  *          wayland_surface_create_plain
  *
@@ -158,9 +227,10 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
     if (!surface->wl_surface)
         goto err;
 
+    wl_list_init(&surface->output_ref_list);
     wl_list_init(&surface->link);
     wl_list_init(&surface->child_list);
-    wl_surface_set_user_data(surface->wl_surface, surface);
+    wl_surface_add_listener(surface->wl_surface, &wl_surface_listener, surface);
     /* Plain surfaces are unmappable, so don't draw on them. */
     surface->drawing_allowed = FALSE;
 
@@ -262,6 +332,8 @@ void wayland_surface_make_subsurface(struct wayland_surface *surface,
         goto err;
     wl_subsurface_set_desync(surface->wl_subsurface);
 
+    surface->main_output = parent->main_output;
+
     wl_surface_commit(surface->wl_surface);
 
     surface->role = WAYLAND_SURFACE_ROLE_SUBSURFACE;
@@ -550,6 +622,7 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     struct wayland_pointer *pointer = &surface->wayland->pointer;
     struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
     struct wayland_surface *child, *child_tmp;
+    struct wayland_output_ref *ref, *ref_tmp;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
@@ -573,6 +646,12 @@ void wayland_surface_destroy(struct wayland_surface *surface)
     }
     wayland_mutex_unlock(&surface->mutex);
 
+    wl_list_for_each_safe(ref, ref_tmp, &surface->output_ref_list, link)
+    {
+        wl_list_remove(&ref->link);
+        free(ref);
+    }
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
@@ -727,3 +806,75 @@ void wayland_surface_unref(struct wayland_surface *surface)
     if (ref == 0)
         wayland_surface_destroy(surface);
 }
+
+static void wayland_surface_tree_set_main_output(struct wayland_surface *surface,
+                                                 struct wayland_output *output)
+{
+    struct wayland_surface *child;
+
+    surface->main_output = output;
+
+    wayland_mutex_lock(&surface->mutex);
+
+    wl_list_for_each(child, &surface->child_list, link)
+        wayland_surface_tree_set_main_output(child, output);
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
+/**********************************************************************
+ *          wayland_surface_set_main_output
+ *
+ * Sets the main output for a surface, i.e., the output whose scale will be
+ * used for surface scaling.
+ */
+static void wayland_surface_set_main_output(struct wayland_surface *surface,
+                                            struct wayland_output *output)
+{
+    /* Don't update non-toplevels. */
+    if (surface->parent) return;
+
+    TRACE("surface=%p output->name=%s => output->name=%s\n",
+          surface,
+          surface->main_output ? surface->main_output->name : NULL,
+          output ? output->name : NULL);
+
+    if (surface->main_output != output)
+    {
+        wayland_surface_tree_set_main_output(surface, output);
+        if (surface->hwnd)
+            send_message(surface->hwnd, WM_WAYLAND_SURFACE_OUTPUT_CHANGE, 0, 0);
+    }
+}
+
+/**********************************************************************
+ *          wayland_surface_leave_output
+ *
+ * Removes an output from the set of outputs a surface is presented on.
+ *
+ * It is OK to call this function even if the surface is not presented
+ * on the specified output, in which case this function is a NOP.
+ */
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output)
+{
+    struct wayland_output_ref *ref, *tmp;
+
+    wl_list_for_each_safe(ref, tmp, &surface->output_ref_list, link)
+    {
+        if (ref->output == output)
+        {
+            wl_list_remove(&ref->link);
+            free(ref);
+            break;
+        }
+    }
+
+    if (surface->main_output == output)
+    {
+        struct wayland_output *origin =
+            wayland_surface_get_origin_output(surface);
+
+        wayland_surface_set_main_output(surface, origin);
+    }
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 5b72a345253..3ccb57d9f71 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -65,6 +65,7 @@ enum wayland_window_message
     WM_WAYLAND_QUERY_SURFACE_MAPPED,
     WM_WAYLAND_CONFIGURE,
     WM_WAYLAND_STATE_UPDATE,
+    WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
 };
 
 enum wayland_surface_role
@@ -196,6 +197,12 @@ struct wayland_surface_configure
     BOOL processed;
 };
 
+struct wayland_output_ref
+{
+    struct wl_list link;
+    struct wayland_output *output;
+};
+
 struct wayland_surface
 {
     struct wl_list link;
@@ -212,6 +219,8 @@ struct wayland_surface
     BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
+    struct wl_list output_ref_list;
+    struct wayland_output *main_output;
     BOOL drawing_allowed;
     struct wl_list child_list;
 };
@@ -358,6 +367,8 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
                                     int *wine_x, int *wine_y) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_leave_output(struct wayland_surface *surface,
+                                  struct wayland_output *output) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland native buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 29954b8d2bd..a8afca91c4f 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1350,13 +1350,22 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
      * to the user from a wayland compositor pespective. To mitigate this, we
      * place all top-level windows at 0,0, to maximize the area that can reside
      * within the win32 display. */
-    origin_x = 0;
-    origin_y = 0;
-    needs_move_to_origin = data->window_rect.top != origin_x ||
-                           data->window_rect.left != origin_y;
-    TRACE("current=%d,%d origin=%d,%d\n",
-          data->window_rect.left, data->window_rect.top,
-          origin_x, origin_y);
+    if (data->wayland_surface->main_output)
+    {
+        origin_x = data->wayland_surface->main_output->x;
+        origin_y = data->wayland_surface->main_output->y;
+        needs_move_to_origin = data->window_rect.top != origin_x ||
+                               data->window_rect.left != origin_y;
+        TRACE("current=%d,%d origin=%d,%d\n",
+              data->window_rect.left, data->window_rect.top,
+              origin_x, origin_y);
+    }
+    else
+    {
+        origin_x = 0;
+        origin_y = 0;
+        needs_move_to_origin = FALSE;
+    }
 
     wayland_win_data_release(data);
 
@@ -1415,6 +1424,67 @@ static void CALLBACK post_configure(HWND hwnd, UINT msg, UINT_PTR timer_id, DWOR
     handle_wm_wayland_configure(hwnd);
 }
 
+static void handle_wm_wayland_surface_output_change(HWND hwnd)
+{
+    struct wayland_surface *wsurface;
+    int x, y, w, h;
+    UINT swp_flags;
+
+    TRACE("hwnd=%p\n", hwnd);
+
+    wsurface = wayland_surface_for_hwnd_lock(hwnd);
+    if (!wsurface || !wsurface->xdg_toplevel)
+    {
+        TRACE("no suitable wayland surface, returning\n");
+        goto out;
+    }
+
+    swp_flags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOOWNERZORDER |
+                SWP_FRAMECHANGED | SWP_NOSENDCHANGING;
+
+    if (wsurface->main_output)
+    {
+        x = wsurface->main_output->x;
+        y = wsurface->main_output->y;
+        TRACE("moving window to %d,%d\n", x, y);
+    }
+    else
+    {
+        x = y = 0;
+        swp_flags |= SWP_NOMOVE;
+    }
+
+    /* If we are fullscreen or maximized we need to provide a particular buffer
+     * size to the wayland compositor on the new output (hence swp_flags
+     * includes SWP_NOSENDCHANGING). */
+    if (wsurface->current.serial &&
+        (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+    {
+        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
+                                       wsurface->current.height,
+                                       &w, &h);
+        TRACE("resizing window to maximized %dx%d\n", w, h);
+    }
+    else if (wsurface->current.serial &&
+             (wsurface->current.configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN))
+    {
+        wayland_surface_coords_to_wine(wsurface, wsurface->current.width,
+                                       wsurface->current.height,
+                                       &w, &h);
+        TRACE("resizing window to fullscreen %dx%d\n", w, h);
+    }
+    else
+    {
+        w = h = 0;
+        swp_flags |= SWP_NOSIZE;
+    }
+
+    NtUserSetWindowPos(hwnd, 0, x, y, w, h, swp_flags);
+
+out:
+    wayland_surface_for_hwnd_unlock(wsurface);
+}
+
 /**********************************************************************
  *           WAYLAND_WindowMessage
  */
@@ -1485,6 +1555,9 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             }
         }
         break;
+    case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
+        handle_wm_wayland_surface_output_change(hwnd);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.36.1

