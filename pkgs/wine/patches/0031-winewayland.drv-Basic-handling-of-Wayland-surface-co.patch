From f4ba7cf0fefaf0d11e77c773e96ac52a1a0436dd Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 28 Sep 2021 12:55:01 +0300
Subject: [PATCH 031/170] winewayland.drv: Basic handling of Wayland surface
 configure events.

Handle the initial configure event for top-level Wayland surfaces.  More
dynamic configure event handling will be implemented in future commits.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 89 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      | 19 ++++++
 2 files changed, 108 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 358d6fbee30..984768c816a 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -31,6 +31,89 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
+static void handle_xdg_surface_configure(void *data, struct xdg_surface *xdg_surface,
+                                         uint32_t serial)
+{
+    struct wayland_surface *surface = data;
+
+    TRACE("serial=%u\n", serial);
+
+    surface->pending.serial = serial;
+
+    wayland_surface_ack_pending_configure(surface);
+}
+
+/**********************************************************************
+ *          wayland_surface_ack_pending_configure
+ *
+ * Acks the pending configure event, making it current.
+ */
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface)
+{
+    if (!surface->xdg_surface || !surface->pending.serial)
+        return;
+
+    TRACE("Setting current serial=%u size=%dx%d flags=%#x\n",
+          surface->pending.serial, surface->pending.width,
+          surface->pending.height, surface->pending.configure_flags);
+
+    surface->current = surface->pending;
+    xdg_surface_ack_configure(surface->xdg_surface, surface->current.serial);
+
+    memset(&surface->pending, 0, sizeof(surface->pending));
+}
+
+static const struct xdg_surface_listener xdg_surface_listener = {
+    handle_xdg_surface_configure,
+};
+
+static void handle_xdg_toplevel_configure(void *data,
+                                          struct xdg_toplevel *xdg_toplevel,
+                                          int32_t width, int32_t height,
+                                          struct wl_array *states)
+{
+    struct wayland_surface *surface = data;
+    uint32_t *state;
+    int flags = 0;
+
+    wl_array_for_each(state, states)
+    {
+        switch(*state)
+        {
+        case XDG_TOPLEVEL_STATE_MAXIMIZED:
+            flags |= WAYLAND_CONFIGURE_FLAG_MAXIMIZED;
+            break;
+        case XDG_TOPLEVEL_STATE_ACTIVATED:
+            flags |= WAYLAND_CONFIGURE_FLAG_ACTIVATED;
+            break;
+        case XDG_TOPLEVEL_STATE_RESIZING:
+            flags |= WAYLAND_CONFIGURE_FLAG_RESIZING;
+            break;
+        case XDG_TOPLEVEL_STATE_FULLSCREEN:
+            flags |= WAYLAND_CONFIGURE_FLAG_FULLSCREEN;
+            break;
+        default:
+            break;
+        }
+    }
+
+    surface->pending.width = width;
+    surface->pending.height = height;
+    surface->pending.configure_flags = flags;
+
+    TRACE("%dx%d flags=%#x\n", width, height, flags);
+}
+
+static void handle_xdg_toplevel_close(void *data, struct xdg_toplevel *xdg_toplevel)
+{
+    TRACE("\n");
+}
+
+static const struct xdg_toplevel_listener xdg_toplevel_listener = {
+    handle_xdg_toplevel_configure,
+    handle_xdg_toplevel_close,
+};
+
 /**********************************************************************
  *          wayland_surface_create_plain
  *
@@ -82,10 +165,12 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
         xdg_wm_base_get_xdg_surface(wayland->xdg_wm_base, surface->wl_surface);
     if (!surface->xdg_surface)
         goto err;
+    xdg_surface_add_listener(surface->xdg_surface, &xdg_surface_listener, surface);
 
     surface->xdg_toplevel = xdg_surface_get_toplevel(surface->xdg_surface);
     if (!surface->xdg_toplevel)
         goto err;
+    xdg_toplevel_add_listener(surface->xdg_toplevel, &xdg_toplevel_listener, surface);
 
     if (parent && parent->xdg_toplevel)
         xdg_toplevel_set_parent(surface->xdg_toplevel, parent->xdg_toplevel);
@@ -94,6 +179,10 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 
     surface->role = WAYLAND_SURFACE_ROLE_TOPLEVEL;
 
+    /* Wait for the first configure event. */
+    while (!surface->current.serial)
+        wl_display_roundtrip_queue(wayland->wl_display, wayland->wl_event_queue);
+
     return;
 
 err:
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index afb3f5e875d..50e22392c42 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -62,6 +62,14 @@ enum wayland_surface_role
     WAYLAND_SURFACE_ROLE_TOPLEVEL,
 };
 
+enum wayland_configure_flags
+{
+    WAYLAND_CONFIGURE_FLAG_RESIZING   = (1 << 0),
+    WAYLAND_CONFIGURE_FLAG_ACTIVATED  = (1 << 1),
+    WAYLAND_CONFIGURE_FLAG_MAXIMIZED  = (1 << 2),
+    WAYLAND_CONFIGURE_FLAG_FULLSCREEN = (1 << 3),
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -120,6 +128,14 @@ struct wayland_output
     uint32_t global_id;
 };
 
+struct wayland_surface_configure
+{
+    int width;
+    int height;
+    enum wayland_configure_flags configure_flags;
+    uint32_t serial;
+};
+
 struct wayland_surface
 {
     struct wayland *wayland;
@@ -128,6 +144,8 @@ struct wayland_surface
     struct xdg_surface *xdg_surface;
     struct xdg_toplevel *xdg_toplevel;
     struct wayland_surface *parent;
+    struct wayland_surface_configure pending;
+    struct wayland_surface_configure current;
     LONG ref;
     enum wayland_surface_role role;
 };
@@ -244,6 +262,7 @@ void wayland_surface_make_toplevel(struct wayland_surface *surface,
 void wayland_surface_make_subsurface(struct wayland_surface *surface,
                                      struct wayland_surface *parent) DECLSPEC_HIDDEN;
 void wayland_surface_destroy(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_ack_pending_configure(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 
-- 
2.36.1

