From dee503c824179c06f522adc9c09cfe37eb58568e Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 4 Oct 2021 13:02:25 +0300
Subject: [PATCH 045/170] winewayland.drv: Implement SetCursor.

Instruct the Wayland compositor to set or update the cursor surface for
the Wayland surface that has the pointer focus when SetCursor is called.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland_cursor.c  | 403 +++++++++++++++++++++++++
 dlls/winewayland.drv/wayland_pointer.c |  26 ++
 dlls/winewayland.drv/waylanddrv.h      |  25 +-
 dlls/winewayland.drv/waylanddrv_main.c |   3 +
 dlls/winewayland.drv/window.c          |   4 +
 6 files changed, 461 insertions(+), 1 deletion(-)
 create mode 100644 dlls/winewayland.drv/wayland_cursor.c

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 20821660df0..2232c7aee9e 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -15,6 +15,7 @@ C_SRCS = \
 	unicode.c \
 	wayland.c \
 	wayland_buffer_queue.c \
+	wayland_cursor.c \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
new file mode 100644
index 00000000000..5dab96331fe
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -0,0 +1,403 @@
+/*
+ * Wayland cursor handling
+ *
+ * Copyright 1993, 1994, 1995, 1996, 2001, 2013-2017 Alexandre Julliard
+ * Copyright 1993 David Metcalfe
+ * Copyright 1995, 1996 Alex Korobka
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "waylanddrv.h"
+
+#include "ntgdi.h"
+#include "ntuser.h"
+#include "wine/debug.h"
+#include "wine/server.h"
+
+#include <stdlib.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+static HCURSOR last_cursor;
+static HCURSOR invalid_cursor;
+
+/***********************************************************************
+ *           get_icon_info
+ *
+ * Local GetIconInfoExW helper implementation.
+ */
+static BOOL get_icon_info(HICON handle, ICONINFOEXW *ret)
+{
+    UNICODE_STRING module, res_name;
+    ICONINFO info;
+
+    module.Buffer = ret->szModName;
+    module.MaximumLength = sizeof(ret->szModName) - sizeof(WCHAR);
+    res_name.Buffer = ret->szResName;
+    res_name.MaximumLength = sizeof(ret->szResName) - sizeof(WCHAR);
+    if (!NtUserGetIconInfo(handle, &info, &module, &res_name, NULL, 0)) return FALSE;
+    ret->fIcon = info.fIcon;
+    ret->xHotspot = info.xHotspot;
+    ret->yHotspot = info.yHotspot;
+    ret->hbmColor = info.hbmColor;
+    ret->hbmMask = info.hbmMask;
+    ret->wResID = res_name.Length ? 0 : LOWORD(res_name.Buffer);
+    ret->szModName[module.Length] = 0;
+    ret->szResName[res_name.Length] = 0;
+    return TRUE;
+}
+
+/***********************************************************************
+ *           create_mono_cursor_buffer
+ *
+ * Return a monochrome icon/cursor wl_shm_buffer
+ */
+static struct wayland_shm_buffer *create_mono_cursor_buffer(struct wayland *wayland,
+                                                            HBITMAP bmp)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    BITMAP bm;
+    char *mask = NULL;
+    unsigned int i, j, stride, mask_size, *ptr;
+
+    if (!NtGdiExtGetObjectW(bmp, sizeof(bm), &bm)) return NULL;
+    stride = ((bm.bmWidth + 15) >> 3) & ~1;
+    mask_size = stride * bm.bmHeight;
+    if (!(mask = malloc(mask_size))) return NULL;
+    if (!NtGdiGetBitmapBits(bmp, mask_size, mask)) goto done;
+
+    bm.bmHeight /= 2;
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto done;
+
+    ptr = shm_buffer->map_data;
+    for (i = 0; i < bm.bmHeight; i++)
+    {
+        for (j = 0; j < bm.bmWidth; j++, ptr++)
+        {
+            int and = ((mask[i * stride + j / 8] << (j % 8)) & 0x80);
+            int xor = ((mask[(i + bm.bmHeight) * stride + j / 8] << (j % 8)) & 0x80);
+            if (!xor && and)
+                *ptr = 0;
+            else if (xor && !and)
+                *ptr = 0xffffffff;
+            else
+                /* we can't draw "invert" pixels, so render them as black instead */
+                *ptr = 0xff000000;
+        }
+    }
+
+done:
+    free(mask);
+    return shm_buffer;
+}
+
+/***********************************************************************
+ *           get_bitmap_argb
+ *
+ * Return the bitmap bits in ARGB format. Helper for setting icons and cursors.
+ */
+static struct wayland_shm_buffer *create_color_cursor_buffer(struct wayland *wayland,
+                                                             HDC hdc, HBITMAP color,
+                                                             HBITMAP mask)
+{
+    struct wayland_shm_buffer *shm_buffer = NULL;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *info = (BITMAPINFO *)buffer;
+    BITMAP bm;
+    unsigned int *ptr, *bits = NULL;
+    unsigned char *mask_bits = NULL;
+    int i, j;
+    BOOL has_alpha = FALSE;
+
+    if (!NtGdiExtGetObjectW(color, sizeof(bm), &bm)) goto failed;
+
+    shm_buffer = wayland_shm_buffer_create(wayland, bm.bmWidth, bm.bmHeight,
+                                           WL_SHM_FORMAT_ARGB8888);
+    if (!shm_buffer) goto failed;
+    bits = shm_buffer->map_data;
+
+    info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
+    info->bmiHeader.biWidth = bm.bmWidth;
+    info->bmiHeader.biHeight = -bm.bmHeight;
+    info->bmiHeader.biPlanes = 1;
+    info->bmiHeader.biBitCount = 32;
+    info->bmiHeader.biCompression = BI_RGB;
+    info->bmiHeader.biSizeImage = bm.bmWidth * bm.bmHeight * 4;
+    info->bmiHeader.biXPelsPerMeter = 0;
+    info->bmiHeader.biYPelsPerMeter = 0;
+    info->bmiHeader.biClrUsed = 0;
+    info->bmiHeader.biClrImportant = 0;
+
+    if (!NtGdiGetDIBitsInternal(hdc, color, 0, bm.bmHeight, bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+
+    for (i = 0; i < bm.bmWidth * bm.bmHeight; i++)
+        if ((has_alpha = (bits[i] & 0xff000000) != 0)) break;
+
+    if (!has_alpha)
+    {
+        unsigned int width_bytes = (bm.bmWidth + 31) / 32 * 4;
+        /* generate alpha channel from the mask */
+        info->bmiHeader.biBitCount = 1;
+        info->bmiHeader.biSizeImage = width_bytes * bm.bmHeight;
+        if (!(mask_bits = malloc(info->bmiHeader.biSizeImage))) goto failed;
+        if (!NtGdiGetDIBitsInternal(hdc, mask, 0, bm.bmHeight, mask_bits, info, DIB_RGB_COLORS, 0, 0)) goto failed;
+        ptr = bits;
+        for (i = 0; i < bm.bmHeight; i++)
+            for (j = 0; j < bm.bmWidth; j++, ptr++)
+                if (!((mask_bits[i * width_bytes + j / 8] << (j % 8)) & 0x80)) *ptr |= 0xff000000;
+        free(mask_bits);
+    }
+
+    return shm_buffer;
+
+failed:
+    if (shm_buffer)
+        wayland_shm_buffer_destroy(shm_buffer);
+    free(mask_bits);
+    return NULL;
+}
+
+static struct wayland_cursor *wayland_cursor_from_win32(struct wayland_pointer *pointer,
+                                                        HCURSOR handle)
+{
+    ICONINFOEXW info = { 0 };
+    struct wayland_cursor *wayland_cursor = NULL;
+    struct wayland_shm_buffer *shm_buffer = NULL;
+
+    if (!handle) return NULL;
+
+    wayland_cursor = calloc(1, sizeof(*wayland_cursor));
+    if (!wayland_cursor) goto out;
+
+    if (!get_icon_info(handle, &info)) goto out;
+
+    if (info.hbmColor)
+    {
+        HDC hdc = NtGdiCreateCompatibleDC(0);
+        shm_buffer = create_color_cursor_buffer(pointer->wayland, hdc,
+                                                info.hbmColor, info.hbmMask);
+        NtGdiDeleteObjectApp(hdc);
+    }
+    else
+    {
+        shm_buffer = create_mono_cursor_buffer(pointer->wayland, info.hbmMask);
+    }
+
+    if (!shm_buffer) goto out;
+
+    wayland_cursor->width = shm_buffer->width;
+    wayland_cursor->height = shm_buffer->height;
+    wayland_cursor->wl_buffer =
+        wayland_shm_buffer_steal_wl_buffer_and_destroy(shm_buffer);
+
+    /* make sure hotspot is valid */
+    if (info.xHotspot >= wayland_cursor->width ||
+        info.yHotspot >= wayland_cursor->height)
+    {
+        info.xHotspot = wayland_cursor->width / 2;
+        info.yHotspot = wayland_cursor->height / 2;
+    }
+
+    if (pointer->focused_surface)
+    {
+        wayland_surface_coords_rounded_from_wine(pointer->focused_surface,
+                                                 info.xHotspot, info.yHotspot,
+                                                 &wayland_cursor->hotspot_x,
+                                                 &wayland_cursor->hotspot_y);
+    }
+    else
+    {
+        wayland_cursor->hotspot_x = info.xHotspot;
+        wayland_cursor->hotspot_y = info.yHotspot;
+    }
+
+out:
+    if (info.hbmColor) NtGdiDeleteObjectApp(info.hbmColor);
+    if (info.hbmMask) NtGdiDeleteObjectApp(info.hbmMask);
+    if (wayland_cursor && !wayland_cursor->wl_buffer)
+    {
+        wayland_cursor_destroy(wayland_cursor);
+        wayland_cursor = NULL;
+    }
+    return wayland_cursor;
+}
+
+/***********************************************************************
+ *           wayland_cursor_destroy
+ *
+ *  Destroy a Wayland cursor and its associated resources.
+ */
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor)
+{
+    if (!wayland_cursor)
+        return;
+
+    if (wayland_cursor->wl_buffer)
+        wl_buffer_destroy(wayland_cursor->wl_buffer);
+
+    free(wayland_cursor);
+}
+
+/***********************************************************************
+ *           wayland_pointer_update_cursor_from_win32
+ *
+ *  Update a Wayland pointer to use the specified cursor, or NULL
+ *  to hide the cursor.
+ */
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle)
+{
+    struct wayland_cursor *wayland_cursor = pointer->cursor;
+
+    TRACE("pointer=%p pointer->hcursor=%p handle=%p\n",
+          pointer, pointer ? pointer->hcursor : 0, handle);
+
+    if (!pointer->wl_pointer)
+        return;
+
+    if (pointer->hcursor != handle)
+    {
+        wayland_cursor = wayland_cursor_from_win32(pointer, handle);
+        /* If we can't create a cursor from a valid handle, better to keep the
+         * previous cursor than make it disappear completely. */
+        if (!wayland_cursor && handle)
+            return;
+
+        if (pointer->cursor)
+            wayland_cursor_destroy(pointer->cursor);
+    }
+
+    pointer->cursor = wayland_cursor;
+    pointer->hcursor = handle;
+
+    if (!pointer->cursor)
+    {
+            wl_pointer_set_cursor(pointer->wl_pointer,
+                                  pointer->enter_serial,
+                                  NULL, 0, 0);
+            return;
+    }
+
+    wl_surface_attach(pointer->cursor_wl_surface, pointer->cursor->wl_buffer, 0, 0);
+    wl_surface_damage_buffer(pointer->cursor_wl_surface, 0, 0,
+                             wayland_cursor->width, wayland_cursor->height);
+
+    wl_surface_commit(pointer->cursor_wl_surface);
+
+    wl_pointer_set_cursor(pointer->wl_pointer,
+                          pointer->enter_serial,
+                          pointer->cursor_wl_surface,
+                          pointer->cursor->hotspot_x,
+                          pointer->cursor->hotspot_y);
+}
+
+/***********************************************************************
+ *           wayland_init_set_cursor
+ *
+ *  Initalize internal information, so that we can track the last set
+ *  cursor properly.
+ */
+BOOL wayland_init_set_cursor(void)
+{
+    /* Allocate a handle that we are going to treat as invalid. */
+    SERVER_START_REQ(alloc_user_handle)
+    {
+        if (!wine_server_call_err(req))
+            invalid_cursor = wine_server_ptr_handle(reply->handle);
+    }
+    SERVER_END_REQ;
+
+    TRACE("invalid_cursor=%p\n", invalid_cursor);
+
+    last_cursor = invalid_cursor;
+
+    return invalid_cursor != NULL;
+}
+
+/***********************************************************************
+ *           wayland_invalidate_set_cursor
+ *
+ *  Invalidate the cursor we consider to be set, effectively forcing
+ *  the application of next SetCursor call.
+ */
+HCURSOR wayland_invalidate_set_cursor(void)
+{
+    return __atomic_exchange_n(&last_cursor, invalid_cursor, __ATOMIC_SEQ_CST);
+}
+
+static BOOL wayland_set_cursor(HCURSOR hcursor)
+{
+    HWND foreground = NULL;
+    struct wayland *wayland = thread_wayland();
+
+    if (wayland && wayland->pointer.focused_surface)
+        foreground = wayland->pointer.focused_surface->hwnd;
+
+    if (!foreground)
+        foreground = NtUserGetForegroundWindow();
+
+    if (!foreground)
+        return FALSE;
+
+    send_message(foreground, WM_WAYLAND_SET_CURSOR, 0, (LPARAM)hcursor);
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *           wayland_set_cursor_if_current_invalid
+ *
+ * If the currently set cursor is invalid, apply the provided cursor,
+ * otherwise do nothing.
+ */
+void wayland_set_cursor_if_current_invalid(HCURSOR hcursor)
+{
+    HCURSOR tmp_invalid = invalid_cursor;
+
+    TRACE("hcursor=%p last_cursor=%p\n", hcursor, last_cursor);
+
+    if (hcursor != invalid_cursor &&
+        __atomic_compare_exchange_n(&last_cursor, &tmp_invalid, hcursor,
+                                    FALSE, __ATOMIC_SEQ_CST, __ATOMIC_SEQ_CST))
+    {
+        if (!wayland_set_cursor(hcursor)) wayland_invalidate_set_cursor();
+    }
+}
+
+/***********************************************************************
+ *           WAYLAND_SetCursor
+ */
+void WAYLAND_SetCursor(HCURSOR hcursor)
+{
+    TRACE("hcursor=%p last_cursor=%p\n", hcursor, last_cursor);
+
+    if (__atomic_exchange_n(&last_cursor, hcursor, __ATOMIC_SEQ_CST) != hcursor)
+    {
+        if (!wayland_set_cursor(hcursor)) wayland_invalidate_set_cursor();
+    }
+}
diff --git a/dlls/winewayland.drv/wayland_pointer.c b/dlls/winewayland.drv/wayland_pointer.c
index 46de75d5034..7fb24ae5202 100644
--- a/dlls/winewayland.drv/wayland_pointer.c
+++ b/dlls/winewayland.drv/wayland_pointer.c
@@ -76,6 +76,15 @@ static void pointer_handle_motion(void *data, struct wl_pointer *pointer,
     pointer_handle_motion_internal(data, pointer, time, sx, sy);
 }
 
+static void CALLBACK set_cursor_if_current_invalid(HWND hwnd, UINT msg,
+                                                   UINT_PTR timer_id,
+                                                   DWORD elapsed)
+{
+    TRACE("hwnd=%p\n", hwnd);
+    NtUserKillTimer(hwnd, timer_id);
+    wayland_set_cursor_if_current_invalid((HCURSOR)timer_id);
+}
+
 static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
                                  uint32_t serial, struct wl_surface *surface,
                                  wl_fixed_t sx, wl_fixed_t sy)
@@ -90,9 +99,18 @@ static void pointer_handle_enter(void *data, struct wl_pointer *pointer,
     if (wayland_surface && wayland_surface->hwnd &&
         wayland_surface->wayland == wayland)
     {
+        HCURSOR hcursor;
         TRACE("surface=%p hwnd=%p\n", wayland_surface, wayland_surface->hwnd);
         wayland->pointer.focused_surface = wayland_surface;
         wayland->pointer.enter_serial = serial;
+        /* Invalidate the set cursor cache, so that next update is
+         * unconditionally applied. */
+        hcursor = wayland_invalidate_set_cursor();
+        /* Schedule a cursor update, to ensure the current cursor is applied on
+         * this surface, but only if the application hasn't updated the cursor
+         * in the meantime. */
+        NtUserSetTimer(wayland_surface->hwnd, (UINT_PTR)hcursor, USER_TIMER_MINIMUM,
+                       set_cursor_if_current_invalid, TIMERV_DEFAULT_COALESCING);
         /* Handle the enter as a motion, to account for cases where the
          * window first appears beneath the pointer and won't get a separate
          * motion event. */
@@ -218,6 +236,8 @@ void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayla
     wayland->pointer.wayland = wayland;
     wayland->pointer.wl_pointer = wl_pointer;
     wl_pointer_add_listener(wayland->pointer.wl_pointer, &pointer_listener, wayland);
+    wayland->pointer.cursor_wl_surface =
+        wl_compositor_create_surface(wayland->wl_compositor);
 }
 
 void wayland_pointer_deinit(struct wayland_pointer *pointer)
@@ -225,5 +245,11 @@ void wayland_pointer_deinit(struct wayland_pointer *pointer)
     if (pointer->wl_pointer)
         wl_pointer_destroy(pointer->wl_pointer);
 
+    if (pointer->cursor_wl_surface)
+        wl_surface_destroy(pointer->cursor_wl_surface);
+
+    if (pointer->cursor)
+        wayland_cursor_destroy(pointer->cursor);
+
     memset(pointer, 0, sizeof(*pointer));
 }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 9e04e98cbd3..52abc780efd 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -55,6 +55,7 @@ enum wayland_window_message
 {
     WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
     WM_WAYLAND_MONITOR_CHANGE,
+    WM_WAYLAND_SET_CURSOR,
 };
 
 enum wayland_surface_role
@@ -76,6 +77,9 @@ enum wayland_configure_flags
  *          Definitions for wayland types
  */
 
+struct wayland_surface;
+struct wayland_shm_buffer;
+
 struct wayland_mutex
 {
     pthread_mutex_t mutex;
@@ -84,12 +88,24 @@ struct wayland_mutex
     const char *name;
 };
 
+struct wayland_cursor
+{
+    struct wl_buffer *wl_buffer;
+    int width;
+    int height;
+    int hotspot_x;
+    int hotspot_y;
+};
+
 struct wayland_pointer
 {
     struct wayland *wayland;
     struct wl_pointer *wl_pointer;
     struct wayland_surface *focused_surface;
+    struct wl_surface *cursor_wl_surface;
     uint32_t enter_serial;
+    struct wayland_cursor *cursor;
+    HCURSOR hcursor;
 };
 
 struct wayland
@@ -349,12 +365,18 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 
 /**********************************************************************
- *          Wayland Pointer
+ *          Wayland Pointer/Cursor
  */
 
 void wayland_pointer_init(struct wayland_pointer *pointer, struct wayland *wayland,
                           struct wl_pointer *wl_pointer) DECLSPEC_HIDDEN;
 void wayland_pointer_deinit(struct wayland_pointer *pointer) DECLSPEC_HIDDEN;
+void wayland_cursor_destroy(struct wayland_cursor *wayland_cursor) DECLSPEC_HIDDEN;
+void wayland_pointer_update_cursor_from_win32(struct wayland_pointer *pointer,
+                                              HCURSOR handle) DECLSPEC_HIDDEN;
+BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
+HCURSOR wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
+void wayland_set_cursor_if_current_invalid(HCURSOR hcursor) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
@@ -420,6 +442,7 @@ BOOL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DW
 NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
+void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
 void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 6cf872b22db..05e787656ea 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -137,6 +137,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
+    .pSetCursor = WAYLAND_SetCursor,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
@@ -153,6 +154,8 @@ static NTSTATUS waylanddrv_unix_init(void *arg)
 
     __wine_set_user_driver(&waylanddrv_funcs, WINE_GDI_DRIVER_VERSION);
 
+    if (!wayland_init_set_cursor()) return STATUS_UNSUCCESSFUL;
+
     if (!wayland_process_init()) return STATUS_UNSUCCESSFUL;
 
     /* Read wayland events from a dedicated thread. */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 64a229f6fca..20c86bd7a42 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -445,6 +445,10 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_MONITOR_CHANGE:
         handle_wm_wayland_monitor_change(thread_wayland());
         break;
+    case WM_WAYLAND_SET_CURSOR:
+        wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
+                                                 (HCURSOR)lp);
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.36.1

