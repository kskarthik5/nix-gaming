From d99821c64b1ecc616db4fd2df8c5d472ae1f9512 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:34:39 +0300
Subject: [PATCH 113/170] winewayland.drv: Support front buffer rendering in
 OpenGL.

Mesa Wayland EGL, and Wayland in general, doesn't natively support front
buffer rendering. Emulate it by manually updating the window_surface
front buffer pixels, which are then used as a background during
window_surface flushes.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/opengl.c | 86 +++++++++++++++++++++++++++++++++++
 1 file changed, 86 insertions(+)

diff --git a/dlls/winewayland.drv/opengl.c b/dlls/winewayland.drv/opengl.c
index 2bcc4e95c9b..02493ad1de8 100644
--- a/dlls/winewayland.drv/opengl.c
+++ b/dlls/winewayland.drv/opengl.c
@@ -95,6 +95,7 @@ struct wgl_context
     BOOL       has_been_current;
     BOOL       sharing;
     int        *attribs;
+    BOOL       is_draw_buffer_front;
 };
 
 static void *egl_handle;
@@ -134,6 +135,7 @@ DECL_FUNCPTR(eglSwapBuffers);
 
 static void (*p_glFinish)(void);
 static void (*p_glFlush)(void);
+static void (*p_glDrawBuffer)(GLenum);
 
 static inline BOOL is_onscreen_pixel_format(int format)
 {
@@ -652,6 +654,7 @@ static struct wgl_context *create_context(HDC hdc, struct wgl_context *share,
     ctx->refresh = FALSE;
     ctx->has_been_current = FALSE;
     ctx->sharing = FALSE;
+    ctx->is_draw_buffer_front = FALSE;
 
     /* The gl_object_mutex, which is locked when we get the gl_drawable,
      * also guards access to gl_contexts, so it's safe to add the entry here. */
@@ -986,6 +989,76 @@ out:
     return TRUE;
 }
 
+static void wayland_glDrawBuffer(GLenum mode)
+{
+    struct wgl_context *ctx = NtCurrentTeb()->glContext;
+    GLint draw_fbo = -1;
+
+    if (!ctx) return;
+
+    egl_funcs.gl.p_glGetIntegerv(GL_DRAW_FRAMEBUFFER_BINDING, &draw_fbo);
+
+    TRACE("hwnd %p egl_context %p mode 0x%x draw_fbo %d\n",
+          ctx->draw_hwnd, ctx->context, mode, draw_fbo);
+
+    if (draw_fbo == 0)
+    {
+        BOOL is_draw_buffer_front = (mode == GL_FRONT || mode == GL_FRONT_LEFT);
+        /* Disable the window front buffer if we have one and it's not needed
+         * any longer.  */
+        if (ctx->is_draw_buffer_front && !is_draw_buffer_front)
+            wayland_update_front_buffer(ctx->draw_hwnd, NULL);
+        ctx->is_draw_buffer_front = is_draw_buffer_front;
+    }
+
+    p_glDrawBuffer(mode);
+}
+
+static void read_front_buffer_pixels(void *pixels_out, int width, int height)
+{
+    GLenum prev_read_buffer;
+    GLint prev_read_framebuffer;
+    GLint prev_row_length;
+    GLint prev_image_height;
+    GLint prev_skip_rows;
+    GLint prev_skip_pixels;
+    GLint prev_skip_images;
+    GLint prev_alignment;
+
+    /* Store state we might change */
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_BUFFER, (GLint*)&prev_read_buffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_READ_FRAMEBUFFER_BINDING, &prev_read_framebuffer);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ROW_LENGTH, &prev_row_length);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_IMAGE_HEIGHT, &prev_image_height);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_ROWS, &prev_skip_rows);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_PIXELS, &prev_skip_pixels);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_SKIP_IMAGES, &prev_skip_images);
+    egl_funcs.gl.p_glGetIntegerv(GL_PACK_ALIGNMENT, &prev_alignment);
+
+    /* Set state we need for reading the pixels */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, 0);
+    egl_funcs.gl.p_glReadBuffer(GL_FRONT);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, 0);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, 4);
+
+    egl_funcs.gl.p_glReadPixels(0, 0, width, height, GL_BGRA,  GL_UNSIGNED_BYTE,
+                                pixels_out);
+
+    /* Restore prev state */
+    egl_funcs.ext.p_glBindFramebuffer(GL_READ_FRAMEBUFFER, prev_read_framebuffer);
+    egl_funcs.gl.p_glReadBuffer(prev_read_buffer);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ROW_LENGTH, prev_row_length);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_IMAGE_HEIGHT, prev_image_height);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_ROWS, prev_skip_rows);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_PIXELS, prev_skip_pixels);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_SKIP_IMAGES, prev_skip_images);
+    egl_funcs.gl.p_glPixelStorei(GL_PACK_ALIGNMENT, prev_alignment);
+}
+
 static void wayland_glFinish(void)
 {
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
@@ -994,6 +1067,12 @@ static void wayland_glFinish(void)
     TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
     wgl_context_refresh(ctx);
     p_glFinish();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
 }
 
 static void wayland_glFlush(void)
@@ -1004,6 +1083,12 @@ static void wayland_glFlush(void)
     TRACE("hwnd %p egl_context %p\n", ctx->draw_hwnd, ctx->context);
     wgl_context_refresh(ctx);
     p_glFlush();
+
+    /* Mesa Wayland EGL doesn't currently support front buffer rendering.
+     * For now, emulate it by manually updating the window front buffer
+     * pixels, to be applied when the window surface contents are flushed. */
+    if (ctx->is_draw_buffer_front)
+        wayland_update_front_buffer(ctx->draw_hwnd, read_front_buffer_pixels);
 }
 
 /***********************************************************************
@@ -1425,6 +1510,7 @@ static void init_extensions(int major, int minor)
 
 #define REDIRECT(func) \
     do { p_##func = egl_funcs.gl.p_##func; egl_funcs.gl.p_##func = wayland_##func; } while(0)
+    REDIRECT(glDrawBuffer);
     REDIRECT(glFinish);
     REDIRECT(glFlush);
 #undef REDIRECT
-- 
2.36.1

