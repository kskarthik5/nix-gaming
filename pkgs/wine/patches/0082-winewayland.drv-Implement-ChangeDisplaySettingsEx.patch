From 4cf3635e8f747a33177a41c1af3716c80ae628cf Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 29 Sep 2021 13:47:29 +0300
Subject: [PATCH 082/170] winewayland.drv: Implement ChangeDisplaySettingsEx.

Change the current Wine display mode the and notify all Wayland threads
about the change.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         | 185 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   2 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 3 files changed, 188 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 9fe3912f28d..62498d4f955 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -310,6 +310,42 @@ done:
     return ret;
 }
 
+static BOOL write_registry_settings(const WCHAR *device_name, const DEVMODEW *dm)
+{
+    HANDLE mutex;
+    HKEY hkey;
+    BOOL ret = TRUE;
+
+    mutex = acquire_display_devices_init_mutex();
+    if (!(hkey = get_display_device_reg_key(device_name)))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+#define set_value(name, data) \
+    if (reg_set_value_a(hkey, name, REG_DWORD, (const char*)(data), sizeof(DWORD))) \
+        ret = FALSE
+
+    set_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
+    set_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
+    set_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
+    set_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
+    set_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
+    set_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    set_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
+    set_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
+    set_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef set_value
+
+    NtClose(hkey);
+
+done:
+    release_display_devices_init_mutex(mutex);
+    return ret;
+}
+
 static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
 {
     mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
@@ -435,3 +471,152 @@ err:
     wayland_process_release();
     return FALSE;
 }
+
+static struct wayland_output_mode *get_matching_output_mode_32bpp(struct wayland_output *output,
+                                                                  LPDEVMODEW devmode)
+{
+    struct wayland_output_mode *output_mode;
+    DEVMODEW full_mode;
+
+    if (output->current_wine_mode)
+        populate_devmode(output->current_wine_mode, &full_mode);
+    else
+        populate_devmode(output->current_mode, &full_mode);
+
+    if (devmode->dmFields & DM_PELSWIDTH)
+        full_mode.dmPelsWidth = devmode->dmPelsWidth;
+    if (devmode->dmFields & DM_PELSHEIGHT)
+        full_mode.dmPelsHeight = devmode->dmPelsHeight;
+    if (devmode->dmFields & DM_BITSPERPEL)
+        full_mode.dmBitsPerPel = devmode->dmBitsPerPel;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (full_mode.dmPelsWidth == output_mode->width &&
+            full_mode.dmPelsHeight == output_mode->height &&
+            output_mode->bpp == 32)
+        {
+            return output_mode;
+        }
+    }
+
+    return NULL;
+}
+
+static BOOL wayland_restore_all_outputs(struct wayland *wayland)
+{
+    struct wayland_output *output;
+
+    wl_list_for_each(output, &wayland->output_list, link)
+    {
+        struct wayland_output_mode *output_mode = NULL;
+        DEVMODEW devmode;
+
+        if (read_registry_settings(output->wine_name, &devmode))
+            output_mode = get_matching_output_mode_32bpp(output, &devmode);
+        else
+            output_mode = output->current_mode;
+
+        if (!output_mode)
+            return FALSE;
+
+        if (output_mode != output->current_wine_mode)
+        {
+            wayland_output_set_wine_mode(output, output_mode->width,
+                                         output_mode->height);
+        }
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ *		ChangeDisplaySettingsEx  (WAYLAND.@)
+ *
+ */
+LONG WAYLAND_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
+                                     HWND hwnd, DWORD flags, LPVOID lpvoid)
+{
+    LONG ret;
+    struct wayland *wayland = wayland_process_acquire();
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+
+    TRACE("(%s,%p,%p,0x%08x,%p) %dx%d@%d wayland=%p\n",
+          debugstr_w(devname), devmode, hwnd, flags, lpvoid,
+          devmode ? devmode->dmPelsWidth : -1,
+          devmode ? devmode->dmPelsHeight : -1,
+          devmode ? devmode->dmDisplayFrequency : -1, wayland);
+
+    if (devname && devmode)
+    {
+        DEVMODEW full_mode;
+
+        output = wayland_output_get_by_wine_name(wayland, devname);
+        if (!output)
+        {
+            ret = DISP_CHANGE_BADPARAM;
+            goto out;
+        }
+
+        output_mode = get_matching_output_mode_32bpp(output, devmode);
+        if (!output_mode)
+        {
+            ret = DISP_CHANGE_BADMODE;
+            goto out;
+        }
+
+        populate_devmode(output_mode, &full_mode);
+
+        if (flags & CDS_UPDATEREGISTRY)
+        {
+            if (!write_registry_settings(devname, &full_mode))
+            {
+                ERR("Failed to write %s display settings to registry.\n", wine_dbgstr_w(devname));
+                ret = DISP_CHANGE_NOTUPDATED;
+                goto out;
+            }
+        }
+    }
+
+    if (flags & (CDS_TEST | CDS_NORESET))
+    {
+        ret = DISP_CHANGE_SUCCESSFUL;
+        goto out;
+    }
+
+    if (devname && devmode)
+    {
+        wayland_output_set_wine_mode(output, output_mode->width, output_mode->height);
+    }
+    else
+    {
+        if (!wayland_restore_all_outputs(wayland))
+        {
+            ret = DISP_CHANGE_BADMODE;
+            goto out;
+        }
+    }
+
+    wayland_refresh_display_devices();
+
+    wayland_notify_wine_monitor_change();
+
+    if (devname && devmode)
+    {
+        TRACE("set current wine mode %dx%d wine_scale %f\n",
+              output_mode->width, output_mode->height, output->wine_scale);
+    }
+    else
+    {
+        TRACE("restored all outputs to registry (or native) settings\n");
+    }
+
+    ret = DISP_CHANGE_SUCCESSFUL;
+
+out:
+    wayland_process_release();
+    if (ret == DISP_CHANGE_SUCCESSFUL)
+        wayland_broadcast_wm_display_change();
+    return ret;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 728c08639f5..0c18b2561c6 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -558,6 +558,8 @@ NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *pa
  *          USER driver functions
  */
 
+LONG WAYLAND_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
+                                     HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 BOOL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index efa6c814dd9..6fb0085368f 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -133,6 +133,7 @@ static void WAYLAND_ThreadDetach(void)
 
 static const struct user_driver_funcs waylanddrv_funcs =
 {
+    .pChangeDisplaySettingsEx = WAYLAND_ChangeDisplaySettingsEx,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
-- 
2.36.1

