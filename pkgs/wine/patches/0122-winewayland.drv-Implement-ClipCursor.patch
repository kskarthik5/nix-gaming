From 2f5a011802cb60a535a89ec54fe7b8f26309b3c2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 15 Sep 2021 16:18:20 +0300
Subject: [PATCH 122/170] winewayland.drv: Implement ClipCursor.

Implement cursor clipping by using the zwp_pointer_constraints_v1
and the zwp_relative_pointer_v1 Wayland protocols.

We use a set of heurestics to decide when to constraint the Wayland
pointer and which form of constraint to use for the focused surface:

1. If the cursor isn't visible (i.e., we don't have a current cursor)
   and we have an effective clip for a window, lock the pointer in
   the corresponding Wayland surface and emit relative events (typical
   case for first/third-person perspective 3D games).

2. If the cursor is visible, and we have an effective clip for a window,
   confine the cursor to the clipped area within the corresponding
   Wayland surface and emit absolute events.

3. Otherwise, don't constrain.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/Makefile.in       |   1 +
 dlls/winewayland.drv/wayland.c         |  11 ++
 dlls/winewayland.drv/wayland_cursor.c  |  28 ++++
 dlls/winewayland.drv/wayland_surface.c | 188 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  15 ++
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          |  23 +++
 7 files changed, 267 insertions(+)

diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index fab5a73e04f..b1494ec830e 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -43,6 +43,7 @@ WAYLAND_PROTOCOL_SRCS = \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/viewporter/viewporter.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/stable/xdg-shell/xdg-shell.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/linux-dmabuf/linux-dmabuf-unstable-v1.xml \
+	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/pointer-constraints/pointer-constraints-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/relative-pointer/relative-pointer-unstable-v1.xml \
 	$(WAYLAND_PROTOCOLS_DATADIR)/unstable/xdg-output/xdg-output-unstable-v1.xml \
 
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index 85111b50e33..1a247d0b48c 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -32,6 +32,7 @@
 
 #include <errno.h>
 #include <fcntl.h>
+#include <limits.h>
 #include <poll.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -175,6 +176,11 @@ static void registry_handle_global(void *data, struct wl_registry *registry,
     {
         wayland->wp_viewporter = wl_registry_bind(registry, id, &wp_viewporter_interface, 1);
     }
+    else if (strcmp(interface, "zwp_pointer_constraints_v1") == 0)
+    {
+        wayland->zwp_pointer_constraints_v1 =
+            wl_registry_bind(registry, id, &zwp_pointer_constraints_v1_interface, 1);
+    }
     else if (strcmp(interface, "zwp_relative_pointer_manager_v1") == 0)
     {
         wayland->zwp_relative_pointer_manager_v1 =
@@ -271,6 +277,8 @@ BOOL wayland_init(struct wayland *wayland)
     wl_list_init(&wayland->detached_shm_buffer_list);
     wl_list_init(&wayland->toplevel_list);
 
+    SetRect(&wayland->cursor_clip, INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+
     /* Populate registry */
     wl_registry_add_listener(wayland->wl_registry, &registry_listener, wayland);
 
@@ -353,6 +361,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->dmabuf.zwp_linux_dmabuf_v1)
         wayland_dmabuf_deinit(&wayland->dmabuf);
 
+    if (wayland->zwp_pointer_constraints_v1)
+        zwp_pointer_constraints_v1_destroy(wayland->zwp_pointer_constraints_v1);
+
     if (wayland->zwp_relative_pointer_manager_v1)
         zwp_relative_pointer_manager_v1_destroy(wayland->zwp_relative_pointer_manager_v1);
 
diff --git a/dlls/winewayland.drv/wayland_cursor.c b/dlls/winewayland.drv/wayland_cursor.c
index a0ff8bc7722..2ab887d75d5 100644
--- a/dlls/winewayland.drv/wayland_cursor.c
+++ b/dlls/winewayland.drv/wayland_cursor.c
@@ -650,6 +650,10 @@ static BOOL wayland_set_cursor(HCURSOR hcursor)
 
     send_message(foreground, WM_WAYLAND_SET_CURSOR, 0, (LPARAM)hcursor);
 
+    /* Cursor visibility affects pointer confinement mode. */
+    send_message(foreground, WM_WAYLAND_POINTER_CONFINEMENT_UPDATE,
+                 WAYLAND_POINTER_CONFINEMENT_RETAIN_CLIP, 0);
+
     return TRUE;
 }
 
@@ -685,3 +689,27 @@ void WAYLAND_SetCursor(HCURSOR hcursor)
         if (!wayland_set_cursor(hcursor)) wayland_invalidate_set_cursor();
     }
 }
+
+/***********************************************************************
+ *           WAYLAND_ClipCursor
+ */
+BOOL WAYLAND_ClipCursor(const RECT *clip)
+{
+    HWND foreground = NULL;
+    struct wayland *wayland = thread_wayland();
+    WPARAM confine = clip ? WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP :
+                            WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP;
+
+    if (wayland && wayland->pointer.focused_surface)
+        foreground = wayland->pointer.focused_surface->hwnd;
+
+    if (!foreground)
+        foreground = NtUserGetForegroundWindow();
+
+    if (!foreground)
+        return FALSE;
+
+    send_message(foreground, WM_WAYLAND_POINTER_CONFINEMENT_UPDATE, confine, 0);
+
+    return TRUE;
+}
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 15243863f68..e4c2176bcd9 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -682,6 +682,18 @@ void wayland_surface_destroy(struct wayland_surface *surface)
         free(ref);
     }
 
+    if (surface->zwp_locked_pointer_v1)
+    {
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
     if (surface->wp_viewport)
     {
         wp_viewport_destroy(surface->wp_viewport);
@@ -1242,6 +1254,182 @@ void wayland_surface_unref(struct wayland_surface *surface)
         wayland_surface_destroy(surface);
 }
 
+/**********************************************************************
+ *          wayland_surface_update_pointer_confinement
+ *
+ * Update pointer confinement on the surface. Confinement mode depends
+ * on the current Windows cursor clip and cursor visibility.
+ */
+void wayland_surface_update_pointer_confinement(struct wayland_surface *surface)
+{
+    struct wayland *wayland = surface->wayland;
+    struct wayland_surface *glvk;
+    struct wl_region *region;
+    RECT vscreen_rect;
+    RECT clip_rect = wayland->cursor_clip;
+    RECT client_rect = {0};
+    RECT client_clip_rect;
+    BOOL needs_lock = FALSE;
+    BOOL needs_confine = FALSE;
+
+    if (!wayland->zwp_pointer_constraints_v1 || !wayland->pointer.wl_pointer)
+        return;
+
+    wayland_get_client_rect_in_win_coords(surface->hwnd, &client_rect);
+    NtUserMapWindowPoints(surface->hwnd, NULL, (POINT*)&client_rect, 2);
+
+    vscreen_rect.top = NtUserGetSystemMetrics(SM_YVIRTUALSCREEN);
+    vscreen_rect.left = NtUserGetSystemMetrics(SM_XVIRTUALSCREEN);
+    vscreen_rect.bottom = vscreen_rect.top + NtUserGetSystemMetrics(SM_CYVIRTUALSCREEN);
+    vscreen_rect.right = vscreen_rect.left + NtUserGetSystemMetrics(SM_CXVIRTUALSCREEN);
+
+    /* Get the effective clip area, if any. */
+    intersect_rect(&clip_rect, &clip_rect, &vscreen_rect);
+    intersect_rect(&client_clip_rect, &clip_rect, &client_rect);
+
+    TRACE("wayland=%p surface=%p (glvk=%p) clip_rect=%s client_clip_rect=%s "
+          "client=%s vscreen=%s hcursor=%p\n",
+          wayland, surface, surface->glvk,
+          wine_dbgstr_rect(&clip_rect), wine_dbgstr_rect(&client_clip_rect),
+          wine_dbgstr_rect(&client_rect),
+          wine_dbgstr_rect(&vscreen_rect),
+          wayland->pointer.hcursor);
+
+    /* If there is a GL/VK subsurface use that to apply the pointer constaints,
+     * since it's covering the whole client area. */
+    glvk = wayland_surface_ref_glvk(surface);
+    if (glvk)
+    {
+        if (surface->zwp_locked_pointer_v1)
+        {
+            zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+            surface->zwp_locked_pointer_v1 = NULL;
+        }
+        if (surface->zwp_confined_pointer_v1)
+        {
+            zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+            surface->zwp_confined_pointer_v1 = NULL;
+        }
+        surface = glvk;
+    }
+
+    /* Only confine or lock if the cursor is actually clipped within this window,
+     * or if the clip rect is empty. */
+    if (!IsRectEmpty(&client_clip_rect) || IsRectEmpty(&clip_rect))
+    {
+        /* If the cursor is not visible, and we have an effective clip (i.e.,
+         * clip is not the whole screen) lock the cursor. If the client rect is
+         * the whole screen (i.e., application is fullscreen), we can't
+         * differentiate between an explicit fullscreen clip and no effective
+         * clip (i.e., clip is the whole screen), so also lock. */
+        if (!wayland->pointer.hcursor &&
+            (!EqualRect(&clip_rect, &vscreen_rect) ||
+             EqualRect(&client_rect, &vscreen_rect)))
+        {
+            needs_lock = TRUE;
+        }
+        else if (wayland->pointer.hcursor &&
+                 !EqualRect(&clip_rect, &vscreen_rect))
+        {
+            needs_confine = TRUE;
+        }
+    }
+
+    /* Destroy unneeded interface objects. */
+    if (!needs_lock && surface->zwp_locked_pointer_v1)
+    {
+        POINT cursor_pos;
+
+        if (NtUserGetCursorPos(&cursor_pos) && PtInRect(&client_rect, cursor_pos))
+        {
+            double wayland_x, wayland_y;
+            wayland_surface_coords_from_screen(surface,
+                                               cursor_pos.x, cursor_pos.y,
+                                               &wayland_x, &wayland_y);
+
+            zwp_locked_pointer_v1_set_cursor_position_hint(
+                    surface->zwp_locked_pointer_v1,
+                    wl_fixed_from_double(wayland_x),
+                    wl_fixed_from_double(wayland_y));
+
+            wl_surface_commit(surface->wl_surface);
+        }
+
+        zwp_locked_pointer_v1_destroy(surface->zwp_locked_pointer_v1);
+        surface->zwp_locked_pointer_v1 = NULL;
+    }
+
+    if (!needs_confine && surface->zwp_confined_pointer_v1)
+    {
+        zwp_confined_pointer_v1_destroy(surface->zwp_confined_pointer_v1);
+        surface->zwp_confined_pointer_v1 = NULL;
+    }
+
+    /* Set up (or update) pointer confinement or lock. */
+    if (needs_confine)
+    {
+        double top, left, bottom, right;
+
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.left,
+                                           client_clip_rect.top,
+                                           &left, &top);
+        wayland_surface_coords_from_screen(surface,
+                                           client_clip_rect.right,
+                                           client_clip_rect.bottom,
+                                           &right, &bottom);
+
+        region = wl_compositor_create_region(wayland->wl_compositor);
+        wl_region_add(region, round(left), round(top),
+                      round(right - left), round(bottom - top));
+
+        if (!surface->zwp_confined_pointer_v1)
+        {
+            surface->zwp_confined_pointer_v1 =
+                zwp_pointer_constraints_v1_confine_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    region,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_confined_pointer_v1_set_region(surface->zwp_confined_pointer_v1,
+                                               region);
+        }
+
+        wl_region_destroy(region);
+    }
+    else if (needs_lock)
+    {
+        if (!surface->zwp_locked_pointer_v1)
+        {
+            surface->zwp_locked_pointer_v1 =
+                zwp_pointer_constraints_v1_lock_pointer(
+                    wayland->zwp_pointer_constraints_v1,
+                    surface->wl_surface,
+                    wayland->pointer.wl_pointer,
+                    NULL,
+                    ZWP_POINTER_CONSTRAINTS_V1_LIFETIME_PERSISTENT);
+        }
+        else
+        {
+            zwp_locked_pointer_v1_set_region(surface->zwp_locked_pointer_v1,
+                                             NULL);
+        }
+    }
+
+    if (wayland->pointer.focused_surface == surface)
+        wayland_pointer_set_relative(&wayland->pointer, needs_lock);
+
+    if (needs_confine || needs_lock)
+        wl_surface_commit(surface->wl_surface);
+
+    if (glvk)
+        wayland_surface_unref_glvk(glvk->parent);
+}
+
 static void wayland_surface_tree_set_main_output_and_scale(struct wayland_surface *surface,
                                                            struct wayland_output *output,
                                                            int scale)
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index e454ebbbefc..3ffc9796c77 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -34,6 +34,7 @@
 #include <xkbcommon/xkbcommon.h>
 #include <xkbcommon/xkbcommon-compose.h>
 #include "linux-dmabuf-unstable-v1-client-protocol.h"
+#include "pointer-constraints-unstable-v1-client-protocol.h"
 #include "relative-pointer-unstable-v1-client-protocol.h"
 #include "viewporter-client-protocol.h"
 #include "xdg-output-unstable-v1-client-protocol.h"
@@ -76,6 +77,7 @@ enum wayland_window_message
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
     WM_WAYLAND_WINDOW_SURFACE_FLUSH,
     WM_WAYLAND_REMOTE_SURFACE,
+    WM_WAYLAND_POINTER_CONFINEMENT_UPDATE,
 };
 
 enum wayland_surface_role
@@ -112,6 +114,13 @@ enum wayland_remote_buffer_commit
     WAYLAND_REMOTE_BUFFER_COMMIT_DETACHED,
 };
 
+enum wayland_pointer_confinement
+{
+    WAYLAND_POINTER_CONFINEMENT_RETAIN_CLIP,
+    WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP,
+    WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP,
+};
+
 /**********************************************************************
  *          Definitions for wayland types
  */
@@ -199,6 +208,7 @@ struct wayland
     struct wl_shm *wl_shm;
     struct wl_seat *wl_seat;
     struct wp_viewporter *wp_viewporter;
+    struct zwp_pointer_constraints_v1 *zwp_pointer_constraints_v1;
     struct zwp_relative_pointer_manager_v1 *zwp_relative_pointer_manager_v1;
     struct zxdg_output_manager_v1 *zxdg_output_manager_v1;
     uint32_t next_fallback_output_id;
@@ -212,6 +222,7 @@ struct wayland
     uint32_t last_button_serial;
     DWORD last_event_type;
     int event_notification_pipe[2];
+    RECT cursor_clip;
 };
 
 struct wayland_output_mode
@@ -272,6 +283,8 @@ struct wayland_surface
     struct wp_viewport *wp_viewport;
     struct wayland_surface *parent;
     struct wayland_surface *glvk;
+    struct zwp_confined_pointer_v1 *zwp_confined_pointer_v1;
+    struct zwp_locked_pointer_v1 *zwp_locked_pointer_v1;
     /* The offset of this surface relative to its owning win32 window */
     int offset_x, offset_y;
     HWND hwnd;
@@ -457,6 +470,7 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
 void wayland_surface_ensure_mapped(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
+void wayland_surface_update_pointer_confinement(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_leave_output(struct wayland_surface *surface,
                                   struct wayland_output *output) DECLSPEC_HIDDEN;
 void wayland_surface_set_wine_output(struct wayland_surface *surface,
@@ -692,6 +706,7 @@ NTSTATUS waylanddrv_client_call(enum waylanddrv_client_func func, const void *pa
 
 LONG WAYLAND_ChangeDisplaySettingsEx(LPCWSTR devname, LPDEVMODEW devmode,
                                      HWND hwnd, DWORD flags, LPVOID lpvoid) DECLSPEC_HIDDEN;
+BOOL WAYLAND_ClipCursor(const RECT *clip) DECLSPEC_HIDDEN;
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
 void WAYLAND_DestroyWindow(HWND hwnd) DECLSPEC_HIDDEN;
 BOOL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 5566a21a789..81788fd6d70 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -140,6 +140,7 @@ const struct user_driver_funcs waylanddrv_funcs =
     .dc_funcs.priority = GDI_PRIORITY_GRAPHICS_DRV,
 
     .pChangeDisplaySettingsEx = WAYLAND_ChangeDisplaySettingsEx,
+    .pClipCursor = WAYLAND_ClipCursor,
     .pCreateWindow = WAYLAND_CreateWindow,
     .pDestroyWindow = WAYLAND_DestroyWindow,
     .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ff676c60229..b44b95e06a6 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -37,6 +37,8 @@
 #include <assert.h>
 #include <stdlib.h>
 
+#include <limits.h>
+
 WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 /* private window data */
@@ -871,6 +873,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
         wsurface->drawing_allowed = TRUE;
 
     wayland_mutex_unlock(&wsurface->mutex);
+
+    wayland_surface_update_pointer_confinement(wsurface);
 }
 
 static void update_wayland_state(struct wayland_win_data *data)
@@ -1619,6 +1623,25 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
             wayland_surface_for_hwnd_unlock(wayland_surface);
         }
         break;
+    case WM_WAYLAND_POINTER_CONFINEMENT_UPDATE:
+        {
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            if (wayland_surface)
+            {
+                if (wp == WAYLAND_POINTER_CONFINEMENT_SYSTEM_CLIP)
+                {
+                    NtUserGetClipCursor(&wayland_surface->wayland->cursor_clip);
+                }
+                else if (wp == WAYLAND_POINTER_CONFINEMENT_UNSET_CLIP)
+                {
+                    SetRect(&wayland_surface->wayland->cursor_clip,
+                            INT_MIN, INT_MIN, INT_MAX, INT_MAX);
+                }
+                wayland_surface_update_pointer_confinement(wayland_surface);
+            }
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
-- 
2.36.1

