From 96ad7c092c9b7047931ca31b1813ce8ce6e24dd8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 16:06:08 +0300
Subject: [PATCH 112/170] winewayland.drv: Support front buffer rendering in
 window_surface.

Implement a front buffer for window_surface, which, when enabled, is
used as a background image on which window surface contents are drawn
over.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h     |   7 ++
 dlls/winewayland.drv/window.c         |  39 +++++++++
 dlls/winewayland.drv/window_surface.c | 118 +++++++++++++++++++++++++-
 3 files changed, 160 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 1d7f63c5f05..cc47e493ae6 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -72,6 +72,7 @@ enum wayland_window_message
     WM_WAYLAND_CONFIGURE,
     WM_WAYLAND_STATE_UPDATE,
     WM_WAYLAND_SURFACE_OUTPUT_CHANGE,
+    WM_WAYLAND_WINDOW_SURFACE_FLUSH,
 };
 
 enum wayland_surface_role
@@ -500,6 +501,9 @@ void wayland_window_surface_set_window_region(struct window_surface *window_surf
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
                                            COLORREF color_key, BYTE alpha,
                                            BOOL src_alpha) DECLSPEC_HIDDEN;
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height)) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -537,6 +541,9 @@ BOOL wayland_gbm_init(void) DECLSPEC_HIDDEN;
 
 void wayland_update_gl_drawable_surface(HWND hwnd, struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 void wayland_destroy_gl_drawable(HWND hwnd) DECLSPEC_HIDDEN;
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height)) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Registry helpers
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index bcb7a0dfb56..5c78e6e02bd 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -1602,6 +1602,14 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
     case WM_WAYLAND_SURFACE_OUTPUT_CHANGE:
         handle_wm_wayland_surface_output_change(hwnd);
         break;
+    case WM_WAYLAND_WINDOW_SURFACE_FLUSH:
+        {
+            struct wayland_win_data *data = wayland_win_data_get(hwnd);
+            if (data && data->window_surface)
+                wayland_window_surface_flush(data->window_surface);
+            wayland_win_data_release(data);
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
@@ -1631,3 +1639,34 @@ err:
     ERR("Failed to get client rect for hwnd %p", hwnd);
     SetRectEmpty(client_rect);
 }
+
+/***********************************************************************
+ *           wayland_update_front_buffer
+ *
+ * Update the front buffer we keep for windows that require it (i.e.,
+ * use front buffer rendering). The front buffer is populated by calling
+ * the supplied read_pixels function, which should store the pixels in
+ * the supplied pixels_out memory location. If read_pixels is NULL, the
+ * front buffer is disabled.
+ *
+ * Note that the stored pixels are expected to be in BGRA8888 form with line
+ * order flipped upside down, i.e., starting with the bottom line (this
+ * is the order used, e.g., by glReadPixels).
+ */
+void wayland_update_front_buffer(HWND hwnd,
+                                 void (*read_pixels)(void *pixels_out,
+                                                     int width, int height))
+{
+    struct wayland_win_data *data;
+
+    if ((data = wayland_win_data_get(hwnd)) && data->window_surface)
+    {
+        wayland_window_surface_update_front_buffer(data->window_surface,
+                                                   read_pixels);
+
+        /* Trigger a redraw to apply any front buffer changes. */
+        NtUserPostMessage(hwnd, WM_WAYLAND_WINDOW_SURFACE_FLUSH, 0, 0);
+    }
+
+    wayland_win_data_release(data);
+}
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index eb5ff37a3a8..56174e8dfbe 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -55,6 +55,8 @@ struct wayland_window_surface
     void                 *bits;
     struct wayland_mutex  mutex;
     BOOL                  last_flush_failed;
+    void                 *front_bits; /* Front buffer pixels, stored bottom to top */
+    BOOL                  front_bits_dirty;
     BITMAPINFO            info;
 };
 
@@ -283,6 +285,31 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         }
     }
 
+    /* If we have a front buffer we always copy it to the buffer before copying
+     * the window surface contents, so the whole surface is considered damaged.
+     * We also damage the whole surface if we just cleared the front buffer
+     * (i.e., front_bits == NULL and front_bits_dirty == TRUE). */
+    if (wws->front_bits || wws->front_bits_dirty)
+    {
+        needs_flush |= wws->front_bits_dirty;
+        if (needs_flush)
+        {
+            if (surface_damage_region)
+            {
+                NtGdiSetRectRgn(surface_damage_region,
+                                wws->header.rect.left, wws->header.rect.top,
+                                wws->header.rect.right, wws->header.rect.bottom);
+            }
+            else
+            {
+                surface_damage_region = NtGdiCreateRectRgn(wws->header.rect.left,
+                                                           wws->header.rect.top,
+                                                           wws->header.rect.right,
+                                                           wws->header.rect.bottom);
+            }
+        }
+    }
+
     if (needs_flush && (!wws->wayland_surface || !wws->wayland_buffer_queue))
     {
         TRACE("missing wayland surface=%p buffer_queue=%p, returning\n",
@@ -313,6 +340,30 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     }
     buffer_damage = wayland_shm_buffer_get_damage_clipped(buffer, wws->total_region);
 
+    /* Copy the whole front buffer to wayland SHM buffer. */
+    if (wws->front_bits)
+    {
+        int width = min(wws->info.bmiHeader.biWidth, buffer->width);
+        int height = min(abs(wws->info.bmiHeader.biHeight), buffer->height);
+        int stride = width * 4;
+        unsigned char *src = wws->front_bits;
+        unsigned char *dst = buffer->map_data;
+        int src_stride = wws->info.bmiHeader.biWidth * 4;
+        int dst_stride = buffer->width * 4;
+        int i;
+
+        TRACE("front buffer %p -> %p %dx%d\n", src, dst, width, height);
+
+        /* Front buffer lines are stored bottom to top, so we need to flip
+         * when copying to our buffer. */
+        for (i = 0; i < height; i++)
+        {
+            memcpy(dst + (height - i - 1) * dst_stride,
+                   src + i * src_stride,
+                   stride);
+        }
+    }
+
     rgn_rect = (RECT *)buffer_damage->Buffer;
     rgn_rect_end = rgn_rect + buffer_damage->rdh.nCount;
 
@@ -404,7 +455,11 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     free(buffer_damage);
 
 done:
-    if (!wws->last_flush_failed) reset_bounds(&wws->bounds);
+    if (!wws->last_flush_failed)
+    {
+        reset_bounds(&wws->bounds);
+        wws->front_bits_dirty = FALSE;
+    }
     if (surface_damage_region) NtGdiDeleteObjectApp(surface_damage_region);
     window_surface->funcs->unlock(window_surface);
 }
@@ -425,6 +480,7 @@ static void wayland_window_surface_destroy(struct window_surface *window_surface
     if (wws->wayland_buffer_queue)
         wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
     free(wws->bits);
+    free(wws->front_bits);
     free(wws);
 }
 
@@ -471,6 +527,8 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->color_key    = color_key;
     wws->alpha        = alpha;
     wws->src_alpha    = src_alpha;
+    wws->front_bits   = NULL;
+    wws->front_bits_dirty = FALSE;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -519,10 +577,16 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
                     wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight),
                     get_preferred_format(wws));
     }
-    else if (!wws->wayland_surface && wws->wayland_buffer_queue)
+    else if (!wws->wayland_surface)
     {
-        wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
-        wws->wayland_buffer_queue = NULL;
+        if (wws->wayland_buffer_queue)
+        {
+            wayland_buffer_queue_destroy(wws->wayland_buffer_queue);
+            wws->wayland_buffer_queue = NULL;
+        }
+        free(wws->front_bits);
+        wws->front_bits = NULL;
+        wws->front_bits_dirty = FALSE;
     }
 
     window_surface->funcs->unlock(window_surface);
@@ -554,3 +618,49 @@ void wayland_window_surface_update_layered(struct window_surface *window_surface
 
     window_surface->funcs->unlock(window_surface);
 }
+
+/***********************************************************************
+ *           wayland_window_surface_update_front_buffer
+ */
+void wayland_window_surface_update_front_buffer(struct window_surface *window_surface,
+                                                void (*read_pixels)(void *pixels_out,
+                                                                    int width, int height))
+{
+    struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
+
+    TRACE("hwnd=%p front_bits=%p read_pixels=%p size=%dx%d\n",
+          wws->hwnd, wws->front_bits, read_pixels,
+          wws->info.bmiHeader.biWidth, abs(wws->info.bmiHeader.biHeight));
+
+    window_surface->funcs->lock(window_surface);
+
+    if (!read_pixels)
+    {
+        if (wws->front_bits)
+        {
+            free(wws->front_bits);
+            wws->front_bits = NULL;
+            /* When the front_bits are first invalidated, we mark them as dirty
+             * to force the next window_surface flush. */
+            wws->front_bits_dirty = TRUE;
+        }
+        goto out;
+    }
+
+    if (!wws->front_bits)
+        wws->front_bits = malloc(wws->info.bmiHeader.biSizeImage);
+
+    if (wws->front_bits)
+    {
+        (*read_pixels)(wws->front_bits, wws->info.bmiHeader.biWidth,
+                       abs(wws->info.bmiHeader.biHeight));
+        wws->front_bits_dirty = TRUE;
+    }
+    else
+    {
+        WARN("Failed to allocate memory for front buffer pixels\n");
+    }
+
+out:
+    window_surface->funcs->unlock(window_surface);
+}
-- 
2.36.1

