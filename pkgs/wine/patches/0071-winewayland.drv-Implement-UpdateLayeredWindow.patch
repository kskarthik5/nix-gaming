From f114ea4d9122cf82e0d843d0aa7b60363b86d62a Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 9 Sep 2021 14:39:51 +0300
Subject: [PATCH 071/170] winewayland.drv: Implement UpdateLayeredWindow.

Support per-pixel alpha values and background blending.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/waylanddrv.h      |   8 +-
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 dlls/winewayland.drv/window.c          | 103 +++++++++++++++++++++++--
 dlls/winewayland.drv/window_surface.c  |  39 +++++++---
 4 files changed, 134 insertions(+), 17 deletions(-)

diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 8e50f68d25a..1e23e3f6259 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -394,7 +394,8 @@ struct wayland_shm_buffer *wayland_buffer_queue_acquire_buffer(struct wayland_bu
  */
 
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha) DECLSPEC_HIDDEN;
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha) DECLSPEC_HIDDEN;
 void wayland_window_surface_flush(struct window_surface *window_surface) DECLSPEC_HIDDEN;
 BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC_HIDDEN;
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
@@ -402,7 +403,8 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *surfac
 void wayland_window_surface_set_window_region(struct window_surface *window_surface,
                                               HRGN win_region) DECLSPEC_HIDDEN;
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha) DECLSPEC_HIDDEN;
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha) DECLSPEC_HIDDEN;
 
 /**********************************************************************
  *          Wayland Keyboard
@@ -540,6 +542,8 @@ INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                         LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect) DECLSPEC_HIDDEN;
 SHORT WAYLAND_VkKeyScanEx(WCHAR ch, HKL hkl) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
 void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index f6fd051966e..efa6c814dd9 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -146,6 +146,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pShowWindow = WAYLAND_ShowWindow,
     .pSysCommand = WAYLAND_SysCommand,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
+    .pUpdateLayeredWindow = WAYLAND_UpdateLayeredWindow,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 06441ee1de4..8a4217e7bb6 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -31,6 +31,7 @@
 
 #include "wine/debug.h"
 
+#include "ntgdi.h"
 #include "ntuser.h"
 
 #include <assert.h>
@@ -952,7 +953,7 @@ BOOL WAYLAND_WindowPosChanging(HWND hwnd, HWND insert_after, UINT swp_flags,
     if (!(flags & LWA_COLORKEY)) color_key = CLR_INVALID;
     if (!(flags & LWA_ALPHA)) alpha = 255;
 
-    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha);
+    *surface = wayland_window_surface_create(data->hwnd, &surface_rect, color_key, alpha, FALSE);
 
 done:
     wayland_win_data_release(data);
@@ -1047,7 +1048,7 @@ void WAYLAND_SetWindowStyle(HWND hwnd, INT offset, STYLESTRUCT *style)
     {
         TRACE("hwnd=%p changed layered\n", hwnd);
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255);
+            wayland_window_surface_update_layered(data->window_surface, CLR_INVALID, 255, FALSE);
     }
 
     wayland_win_data_release(data);
@@ -1068,14 +1069,101 @@ void WAYLAND_SetLayeredWindowAttributes(HWND hwnd, COLORREF key, BYTE alpha, DWO
     if ((data = wayland_win_data_get(hwnd)))
     {
         if (data->window_surface)
-            wayland_window_surface_update_layered(data->window_surface, key, alpha);
+            wayland_window_surface_update_layered(data->window_surface, key, alpha, FALSE);
         wayland_win_data_release(data);
     }
 }
 
-static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+/*****************************************************************************
+ *           WAYLAND_UpdateLayeredWindow
+ */
+BOOL WAYLAND_UpdateLayeredWindow(HWND hwnd, const UPDATELAYEREDWINDOWINFO *info,
+                                 const RECT *window_rect)
 {
-    wayland_update_outputs_from_process(wayland);
+    struct window_surface *window_surface;
+    struct wayland_win_data *data;
+    BLENDFUNCTION blend = { AC_SRC_OVER, 0, 255, 0 };
+    COLORREF color_key = (info->dwFlags & ULW_COLORKEY) ? info->crKey : CLR_INVALID;
+    char buffer[FIELD_OFFSET(BITMAPINFO, bmiColors[256])];
+    BITMAPINFO *bmi = (BITMAPINFO *)buffer;
+    void *src_bits, *dst_bits;
+    RECT rect, src_rect;
+    HDC hdc = 0;
+    HBITMAP dib;
+    BOOL ret = FALSE;
+
+    if (!(data = wayland_win_data_get(hwnd))) return FALSE;
+
+    TRACE("hwnd %p colorkey %x dirty %s flags %x src_alpha %d alpha_format %d\n",
+          hwnd, info->crKey, wine_dbgstr_rect(info->prcDirty), info->dwFlags,
+          info->pblend->SourceConstantAlpha, info->pblend->AlphaFormat == AC_SRC_ALPHA);
+
+    rect = *window_rect;
+    OffsetRect(&rect, -window_rect->left, -window_rect->top);
+
+    window_surface = data->window_surface;
+    if (!window_surface || !EqualRect(&window_surface->rect, &rect))
+    {
+        data->window_surface =
+            wayland_window_surface_create(data->hwnd, &rect, 255, color_key, TRUE);
+        if (window_surface) window_surface_release(window_surface);
+        window_surface = data->window_surface;
+        wayland_window_surface_update_wayland_surface(data->window_surface,
+                                                      data->wayland_surface);
+    }
+    else
+    {
+        wayland_window_surface_update_layered(window_surface, 255, color_key, TRUE);
+    }
+
+    if (window_surface) window_surface_add_ref(window_surface);
+    wayland_win_data_release(data);
+
+    if (!window_surface) return FALSE;
+    if (!info->hdcSrc)
+    {
+        window_surface_release(window_surface);
+        return TRUE;
+    }
+
+    dst_bits = window_surface->funcs->get_info(window_surface, bmi);
+
+    if (!(dib = NtGdiCreateDIBSection(info->hdcDst, NULL, 0, bmi, DIB_RGB_COLORS, 0, 0, 0, &src_bits))) goto done;
+    if (!(hdc = NtGdiCreateCompatibleDC(0))) goto done;
+
+    NtGdiSelectBitmap(hdc, dib);
+
+    window_surface->funcs->lock(window_surface);
+
+    if (info->prcDirty)
+    {
+        intersect_rect(&rect, &rect, info->prcDirty);
+        memcpy(src_bits, dst_bits, bmi->bmiHeader.biSizeImage);
+        NtGdiPatBlt(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, BLACKNESS);
+    }
+    src_rect = rect;
+    if (info->pptSrc) OffsetRect(&src_rect, info->pptSrc->x, info->pptSrc->y);
+    NtGdiTransformPoints(info->hdcSrc, (POINT *)&src_rect, (POINT *)&src_rect, 2, NtGdiDPtoLP);
+
+    ret = NtGdiAlphaBlend(hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top,
+                          info->hdcSrc, src_rect.left, src_rect.top,
+                          src_rect.right - src_rect.left, src_rect.bottom - src_rect.top,
+                          (info->dwFlags & ULW_ALPHA) ? *info->pblend : blend, 0);
+    if (ret)
+    {
+        RECT *bounds = window_surface->funcs->get_bounds(window_surface);
+        memcpy(dst_bits, src_bits, bmi->bmiHeader.biSizeImage);
+        union_rect(bounds, bounds, &rect);
+    }
+
+    window_surface->funcs->unlock(window_surface);
+    window_surface->funcs->flush(window_surface);
+
+done:
+    window_surface_release(window_surface);
+    if (hdc) NtGdiDeleteObjectApp(hdc);
+    if (dib) NtGdiDeleteObjectApp(dib);
+    return ret;
 }
 
 static enum xdg_toplevel_resize_edge hittest_to_resize_edge(WPARAM hittest)
@@ -1133,6 +1221,11 @@ done:
     return ret;
 }
 
+static void handle_wm_wayland_monitor_change(struct wayland *wayland)
+{
+    wayland_update_outputs_from_process(wayland);
+}
+
 static LRESULT handle_wm_wayland_configure(HWND hwnd)
 {
     struct wayland_win_data *data;
diff --git a/dlls/winewayland.drv/window_surface.c b/dlls/winewayland.drv/window_surface.c
index ed2b9b13fd0..eb5ff37a3a8 100644
--- a/dlls/winewayland.drv/window_surface.c
+++ b/dlls/winewayland.drv/window_surface.c
@@ -51,6 +51,7 @@ struct wayland_window_surface
     HRGN                  total_region; /* Total region (surface->region AND window_region) */
     COLORREF              color_key;
     BYTE                  alpha;
+    BOOL                  src_alpha;
     void                 *bits;
     struct wayland_mutex  mutex;
     BOOL                  last_flush_failed;
@@ -91,7 +92,7 @@ static int get_preferred_format(struct wayland_window_surface *wws)
     /* Use ARGB to implement window regions (areas out of the region are
      * transparent). */
     if ((window_region && NtUserGetWindowRgnEx(wws->hwnd, window_region, 0) != ERROR) ||
-        wws->color_key != CLR_INVALID || wws->alpha != 255)
+        wws->color_key != CLR_INVALID || wws->alpha != 255 || wws->src_alpha)
         format = WL_SHM_FORMAT_ARGB8888;
     else
         format = WL_SHM_FORMAT_XRGB8888;
@@ -294,9 +295,9 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
     if (!needs_flush) goto done;
 
     TRACE("flushing surface %p hwnd %p surface_rect %s bits %p color_key %08x "
-          "alpha %02x compression %d region %p\n",
+          "alpha %02x src_alpha %d compression %d region %p\n",
           wws, wws->hwnd, wine_dbgstr_rect(&wws->header.rect),
-          wws->bits, wws->color_key, wws->alpha,
+          wws->bits, wws->color_key, wws->alpha, wws->src_alpha,
           wws->info.bmiHeader.biCompression,
           wws->total_region);
 
@@ -337,8 +338,12 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
         height = min(rgn_rect->bottom, buffer->height) - rgn_rect->top;
 
         /* If we have an ARGB buffer we need to explicitly apply the surface
-         * alpha to ensure the destination has sensible alpha values. */
-        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888;
+         * alpha to ensure the destination has sensible alpha values. The
+         * exception is when the surface uses source alpha values and the
+         * surface alpha is 255, in which case we can just copy pixel values
+         * as they are. */
+        apply_surface_alpha = buffer->format == WL_SHM_FORMAT_ARGB8888 &&
+                              (wws->alpha != 255 || !wws->src_alpha);
 
         /* Fast path for full width rectangles. */
         if (width == buffer->width && !apply_surface_alpha &&
@@ -354,12 +359,12 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
             {
                 memcpy(dst, src, width * 4);
             }
-            else if (wws->alpha == 255)
+            else if (wws->alpha == 255 && !wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                     dst[x] = 0xff000000 | src[x];
             }
-            else
+            else if (!wws->src_alpha)
             {
                 for (x = 0; x < width; x++)
                 {
@@ -369,6 +374,16 @@ void wayland_window_surface_flush(struct window_surface *window_surface)
                               (((BYTE)src[x] * wws->alpha / 255)));
                 }
             }
+            else
+            {
+                for (x = 0; x < width; x++)
+                {
+                    dst[x] = ((((BYTE)(src[x] >> 24) * wws->alpha / 255) << 24) |
+                              (((BYTE)(src[x] >> 16) * wws->alpha / 255) << 16) |
+                              (((BYTE)(src[x] >> 8) * wws->alpha / 255) << 8) |
+                              (((BYTE)src[x] * wws->alpha / 255)));
+                }
+            }
 
             if (wws->color_key != CLR_INVALID)
                 for (x = 0; x < width; x++) if ((src[x] & 0xffffff) == wws->color_key) dst[x] = 0;
@@ -428,7 +443,8 @@ static const struct window_surface_funcs wayland_window_surface_funcs =
  *           wayland_window_surface_create
  */
 struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect,
-                                                     COLORREF color_key, BYTE alpha)
+                                                     COLORREF color_key, BYTE alpha,
+                                                     BOOL src_alpha)
 {
     struct wayland_window_surface *wws;
     int width = rect->right - rect->left, height = rect->bottom - rect->top;
@@ -454,6 +470,7 @@ struct window_surface *wayland_window_surface_create(HWND hwnd, const RECT *rect
     wws->hwnd         = hwnd;
     wws->color_key    = color_key;
     wws->alpha        = alpha;
+    wws->src_alpha    = src_alpha;
     wayland_window_surface_set_window_region(&wws->header, (HRGN)1);
     reset_bounds(&wws->bounds);
 
@@ -515,17 +532,19 @@ void wayland_window_surface_update_wayland_surface(struct window_surface *window
  *           wayland_window_surface_update_layered
  */
 void wayland_window_surface_update_layered(struct window_surface *window_surface,
-                                           COLORREF color_key, BYTE alpha)
+                                           COLORREF color_key, BYTE alpha,
+                                           BOOL src_alpha)
 {
     struct wayland_window_surface *wws = wayland_window_surface_cast(window_surface);
 
     window_surface->funcs->lock(window_surface);
 
-    if (alpha != wws->alpha || color_key != wws->color_key)
+    if (alpha != wws->alpha || color_key != wws->color_key || src_alpha != wws->src_alpha)
         *window_surface->funcs->get_bounds(window_surface) = wws->header.rect;
 
     wws->alpha = alpha;
     wws->color_key = color_key;
+    wws->src_alpha = src_alpha;
 
     if (wws->wayland_buffer_queue &&
         wws->wayland_buffer_queue->format != get_preferred_format(wws))
-- 
2.36.1

