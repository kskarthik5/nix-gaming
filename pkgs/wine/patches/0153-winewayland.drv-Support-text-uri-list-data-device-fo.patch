From 03d75590199d017ea7b93bc6cb614e5404018aa7 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 22 Sep 2021 13:12:09 +0300
Subject: [PATCH 153/170] winewayland.drv: Support text/uri-list data device
 format.

Convert between CF_HDROP Windows clipboard format and "text/uri-list"
Wayland clipboard format.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 .../wayland_data_device_format.c              | 362 ++++++++++++++++++
 1 file changed, 362 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_data_device_format.c b/dlls/winewayland.drv/wayland_data_device_format.c
index 57667c9ed58..646e9556d3f 100644
--- a/dlls/winewayland.drv/wayland_data_device_format.c
+++ b/dlls/winewayland.drv/wayland_data_device_format.c
@@ -24,11 +24,15 @@
 
 #include "config.h"
 
+#include "ntstatus.h"
+#define WIN32_NO_STATUS
+
 #include "waylanddrv.h"
 
 #include "wine/debug.h"
 #include "wine/unicode.h"
 
+#include "shlobj.h"
 #include "winternl.h"
 
 #include <errno.h>
@@ -152,6 +156,363 @@ static void export_data(struct wayland_data_device_format *format, int fd, void
     write_all(fd, data, size);
 }
 
+/* Adapted from winex11.drv/clipboard.c */
+static char *decode_uri(const char *uri, size_t uri_length)
+{
+    char *decoded = malloc(uri_length + 1);
+    size_t uri_i = 0;
+    size_t decoded_i = 0;
+
+    if (decoded == NULL)
+        goto err;
+
+    while (uri_i < uri_length)
+    {
+        if (uri[uri_i] == '%')
+        {
+            unsigned long number;
+            char buffer[3];
+
+            if (uri_i + 1 == uri_length || uri_i + 2 == uri_length)
+                goto err;
+
+            buffer[0] = uri[uri_i + 1];
+            buffer[1] = uri[uri_i + 2];
+            buffer[2] = '\0';
+            errno = 0;
+            number = strtoul(buffer, NULL, 16);
+            if (errno != 0) goto err;
+            decoded[decoded_i] = number;
+
+            uri_i += 3;
+            decoded_i++;
+        }
+        else
+        {
+            decoded[decoded_i++] = uri[uri_i++];
+        }
+    }
+
+    decoded[decoded_i] = '\0';
+
+    return decoded;
+
+err:
+    free(decoded);
+    return NULL;
+}
+
+/* based on wine_get_dos_file_name */
+static WCHAR *get_dos_file_name(const char *path)
+{
+    ULONG len = strlen(path) + 9; /* \??\unix prefix */
+    WCHAR *ret;
+
+    if (!(ret = malloc(len * sizeof(WCHAR)))) return NULL;
+    if (wine_unix_to_nt_file_name(path, ret, &len))
+    {
+        free(ret);
+        return NULL;
+    }
+
+    if (ret[5] == ':')
+    {
+        /* get rid of the \??\ prefix */
+        memmove(ret, ret + 4, (len - 4) * sizeof(WCHAR));
+    }
+    else
+    {
+        ret[1] = '\\';
+    }
+    return ret;
+}
+
+/* Adapted from winex11.drv/clipboard.c */
+static WCHAR* decoded_uri_to_dos(const char *uri)
+{
+    WCHAR *ret = NULL;
+
+    if (strncmp(uri, "file:/", 6))
+        return NULL;
+
+    if (uri[6] == '/')
+    {
+        if (uri[7] == '/')
+        {
+            /* file:///path/to/file (nautilus, thunar) */
+            ret = get_dos_file_name(&uri[7]);
+        }
+        else if (uri[7])
+        {
+            /* file://hostname/path/to/file (X file drag spec) */
+            char hostname[256];
+            char *path = strchr(&uri[7], '/');
+            if (path)
+            {
+                *path = '\0';
+                if (strcmp(&uri[7], "localhost") == 0)
+                {
+                    *path = '/';
+                    ret = get_dos_file_name(path);
+                }
+                else if (gethostname(hostname, sizeof(hostname)) == 0)
+                {
+                    if (strcmp(hostname, &uri[7]) == 0)
+                    {
+                        *path = '/';
+                        ret = get_dos_file_name(path);
+                    }
+                }
+            }
+        }
+    }
+    else if (uri[6])
+    {
+        /* file:/path/to/file (konqueror) */
+        ret = get_dos_file_name(&uri[5]);
+    }
+
+    return ret;
+}
+
+static void *import_uri_list(struct wayland_data_device_format *format,
+                             const void *data, size_t data_size, size_t *ret_size)
+{
+    DROPFILES *drop_files = NULL;
+    size_t drop_size;
+    const char *data_end = (const char *) data + data_size;
+    const char *line_start = data;
+    const char *line_end;
+    WCHAR **path;
+    struct wl_array paths;
+    size_t total_chars = 0;
+    WCHAR *dst;
+
+    TRACE("data=%p size=%lu\n", data, (unsigned long)data_size);
+
+    wl_array_init(&paths);
+
+    while (line_start < data_end)
+    {
+        /* RFC 2483 requires CRLF for text/uri-list line termination, but
+         * some applications send LF. Accept both line terminators. */
+        line_end = strchr(line_start, '\n');
+        if (line_end == NULL)
+        {
+            WARN("URI list line doesn't end in (\\r)\\n\n");
+            break;
+        }
+
+        if (line_end > line_start && line_end[-1] == '\r') line_end--;
+
+        if (line_start[0] != '#')
+        {
+            char *decoded_uri = decode_uri(line_start, line_end - line_start);
+            TRACE("decoded_uri=%s\n", decoded_uri);
+            path = wl_array_add(&paths, sizeof *path);
+            if (!path) goto out;
+            *path = decoded_uri_to_dos(decoded_uri);
+            total_chars += strlenW(*path) + 1;
+            free(decoded_uri);
+        }
+
+        line_start = line_end + (*line_end == '\r' ? 2 : 1);
+    }
+
+    /* DROPFILES points to an array of consecutive null terminated WCHAR strings,
+     * followed by a final 0 WCHAR to denote the end of the array. We place that
+     * array just after the DROPFILE struct itself. */
+    drop_size = sizeof(DROPFILES) + (total_chars + 1) * sizeof(WCHAR);
+    if (!(drop_files = malloc(drop_size)))
+        goto out;
+
+    drop_files->pFiles = sizeof(*drop_files);
+    drop_files->pt.x = 0;
+    drop_files->pt.y = 0;
+    drop_files->fNC = FALSE;
+    drop_files->fWide = TRUE;
+
+    dst = (WCHAR *)(drop_files + 1);
+    wl_array_for_each(path, &paths)
+    {
+        strcpyW(dst, *path);
+        dst += strlenW(*path) + 1;
+    }
+    *dst = 0;
+
+    if (ret_size) *ret_size = drop_size;
+
+out:
+    wl_array_for_each(path, &paths)
+        free(*path);
+
+    wl_array_release(&paths);
+
+    return drop_files;
+}
+
+static CPTABLEINFO *get_ansi_cp(void)
+{
+    USHORT utf8_hdr[2] = { 0, CP_UTF8 };
+    static CPTABLEINFO cp;
+    if (!cp.CodePage)
+    {
+        if (NtCurrentTeb()->Peb->AnsiCodePageData)
+            RtlInitCodePageTable(NtCurrentTeb()->Peb->AnsiCodePageData, &cp);
+        else
+            RtlInitCodePageTable(utf8_hdr, &cp);
+    }
+    return &cp;
+}
+
+/* Helper functions to implement export_hdrop, adapted from winex11.drv */
+
+static BOOL get_nt_pathname(const WCHAR *name, UNICODE_STRING *nt_name)
+{
+    static const WCHAR ntprefixW[] = {'\\','?','?','\\'};
+    static const WCHAR uncprefixW[] = {'U','N','C','\\'};
+    size_t len = lstrlenW(name);
+    WCHAR *ptr;
+
+    nt_name->MaximumLength = (len + 8) * sizeof(WCHAR);
+    if (!(ptr = malloc(nt_name->MaximumLength))) return FALSE;
+    nt_name->Buffer = ptr;
+
+    memcpy(ptr, ntprefixW, sizeof(ntprefixW));
+    ptr += ARRAYSIZE(ntprefixW);
+    if (name[0] == '\\' && name[1] == '\\')
+    {
+        if ((name[2] == '.' || name[2] == '?') && name[3] == '\\')
+        {
+            name += 4;
+            len -= 4;
+        }
+        else
+        {
+            memcpy(ptr, uncprefixW, sizeof(uncprefixW));
+            ptr += ARRAYSIZE(uncprefixW);
+            name += 2;
+            len -= 2;
+        }
+    }
+    memcpy(ptr, name, (len + 1) * sizeof(WCHAR));
+    ptr += len;
+    nt_name->Length = (ptr - nt_name->Buffer) * sizeof(WCHAR);
+    return TRUE;
+}
+
+static char *get_unix_file_name(const WCHAR *dosW)
+{
+    UNICODE_STRING nt_name;
+    OBJECT_ATTRIBUTES attr;
+    NTSTATUS status;
+    ULONG size = 256;
+    char *buffer;
+
+    if (!get_nt_pathname(dosW, &nt_name)) return NULL;
+    InitializeObjectAttributes(&attr, &nt_name, 0, 0, NULL);
+    for (;;)
+    {
+        if (!(buffer = malloc(size)))
+        {
+            free(nt_name.Buffer);
+            return NULL;
+        }
+        status = wine_nt_to_unix_file_name(&attr, buffer, &size, FILE_OPEN_IF);
+        if (status != STATUS_BUFFER_TOO_SMALL) break;
+        free(buffer);
+    }
+    free(nt_name.Buffer);
+    if (status)
+    {
+        free(buffer);
+        return NULL;
+    }
+    return buffer;
+}
+
+/* Export text/uri-list to CF_HDROP, adapted from winex11.drv */
+static void export_hdrop(struct wayland_data_device_format *format, int fd,
+                         void *data, size_t size)
+{
+    char *textUriList = NULL;
+    UINT textUriListSize = 32;
+    UINT next = 0;
+    const WCHAR *ptr;
+    WCHAR *unicode_data = NULL;
+    DROPFILES *drop_files = data;
+
+    if (!drop_files->fWide)
+    {
+        char *files = (char *)data + drop_files->pFiles;
+        CPTABLEINFO *cp = get_ansi_cp();
+        DWORD len = 0;
+
+        while (files[len]) len += strlen(files + len) + 1;
+        len++;
+
+        if (!(ptr = unicode_data = malloc(len * sizeof(WCHAR)))) goto out;
+
+        if (cp->CodePage == CP_UTF8)
+            RtlUTF8ToUnicodeN(unicode_data, len * sizeof(WCHAR), &len, files, len);
+        else
+            RtlCustomCPToUnicodeN(cp, unicode_data, len * sizeof(WCHAR), &len, files, len);
+    }
+    else ptr = (const WCHAR *)((char *)data + drop_files->pFiles);
+
+    if (!(textUriList = malloc(textUriListSize))) goto out;
+
+    while (*ptr)
+    {
+        char *unixFilename = NULL;
+        UINT uriSize;
+        UINT u;
+
+        unixFilename = get_unix_file_name(ptr);
+        if (unixFilename == NULL) goto out;
+        ptr += lstrlenW(ptr) + 1;
+
+        uriSize = 8 + /* file:/// */
+                  3 * (lstrlenA(unixFilename) - 1) + /* "%xy" per char except first '/' */
+                  2; /* \r\n */
+        if ((next + uriSize) > textUriListSize)
+        {
+            UINT biggerSize = max(2 * textUriListSize, next + uriSize);
+            void *bigger = realloc(textUriList, biggerSize);
+            if (bigger)
+            {
+                textUriList = bigger;
+                textUriListSize = biggerSize;
+            }
+            else
+            {
+                free(unixFilename);
+                goto out;
+            }
+        }
+        lstrcpyA(&textUriList[next], "file:///");
+        next += 8;
+        /* URL encode everything - unnecessary, but easier/lighter than
+         * linking in shlwapi, and can't hurt */
+        for (u = 1; unixFilename[u]; u++)
+        {
+            static const char hex_table[] = "0123456789abcdef";
+            textUriList[next++] = '%';
+            textUriList[next++] = hex_table[unixFilename[u] >> 4];
+            textUriList[next++] = hex_table[unixFilename[u] & 0xf];
+        }
+        textUriList[next++] = '\r';
+        textUriList[next++] = '\n';
+        free(unixFilename);
+    }
+
+    write_all(fd, textUriList, next);
+
+out:
+    free(unicode_data);
+    free(textUriList);
+}
+
 #define CP_ASCII 20127
 
 static const WCHAR rich_text_formatW[] = {'R','i','c','h',' ','T','e','x','t',' ','F','o','r','m','a','t',0};
@@ -165,6 +526,7 @@ static struct wayland_data_device_format supported_formats[] =
     {"text/plain", CF_UNICODETEXT, NULL, import_text_as_unicode, export_text, CP_ASCII},
     {"text/rtf", 0, rich_text_formatW, import_data, export_data, 0},
     {"text/richtext", 0, rich_text_formatW, import_data, export_data, 0},
+    {"text/uri-list", CF_HDROP, NULL, import_uri_list, export_hdrop, 0},
     {NULL, 0, NULL, NULL, NULL, 0},
 };
 
-- 
2.36.1

