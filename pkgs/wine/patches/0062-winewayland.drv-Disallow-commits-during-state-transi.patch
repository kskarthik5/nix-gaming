From db6f8efda28d5f4b4c2e5003ed187f5e425769a5 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:09:31 +0300
Subject: [PATCH 062/170] winewayland.drv: Disallow commits during state
 transitions.

When a surface transitions to a new state, disallow commits until the
compositor has acknowledged the transition, in order to avoid glitches.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 10 ++++++----
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 dlls/winewayland.drv/window.c          |  3 +++
 3 files changed, 10 insertions(+), 4 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index cfce5924bfc..ffd2bb3c911 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -141,6 +141,7 @@ struct wayland_surface *wayland_surface_create_plain(struct wayland *wayland)
         goto err;
 
     wl_surface_set_user_data(surface->wl_surface, surface);
+    surface->drawing_allowed = TRUE;
 
     surface->ref = 1;
     surface->role = WAYLAND_SURFACE_ROLE_NONE;
@@ -442,10 +443,11 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
      * they accept. To avoid wayland protocol errors, drop buffers not matching
      * the expected dimensions of such surfaces. This typically happens
      * transiently during resizing operations. */
-    if (!wayland_surface_configure_is_compatible(&surface->current,
-                                                 wayland_width,
-                                                 wayland_height,
-                                                 surface->current.configure_flags))
+    if (!surface->drawing_allowed ||
+        !wayland_surface_configure_is_compatible(&surface->current,
+                                             wayland_width,
+                                             wayland_height,
+                                             surface->current.configure_flags))
     {
         wayland_mutex_unlock(&surface->mutex);
         TRACE("surface=%p buffer=%p dropping buffer\n", surface, shm_buffer);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index dbf9f7572a3..bf9a97f0a6c 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -206,6 +206,7 @@ struct wayland_surface
     BOOL mapped;
     LONG ref;
     enum wayland_surface_role role;
+    BOOL drawing_allowed;
 };
 
 struct wayland_native_buffer
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index ee477e0a0b9..7af96b1103a 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -657,6 +657,7 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     {
         TRACE("hwnd=%p window state not compatible with current or "
               "pending wayland surface configuration\n", data->hwnd);
+        wsurface->drawing_allowed = FALSE;
         return FALSE;
     }
 
@@ -792,6 +793,8 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
 
     wayland_surface_reconfigure_apply(wsurface);
 
+    wsurface->drawing_allowed = TRUE;
+
     wayland_mutex_unlock(&wsurface->mutex);
 }
 
-- 
2.36.1

