From 27f7a50125f5754ae9d9d2f3678c2a2b5f77a1c8 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 5 May 2022 12:46:37 +0300
Subject: [PATCH 088/170] winewayland.drv: Introduce support for GBM.

We will be using GBM to allocate buffers for OpenGL rendering.

GBM requires a valid DRM device. We try to find a suitable device,
prioritizing DRM render nodes over DRM primary nodes. The user
can specify a particular DRM device using the "DRMDevice" driver
registry option.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                    |  81 ++++++++
 configure.ac                                 |   4 +
 dlls/winewayland.drv/Makefile.in             |   5 +-
 dlls/winewayland.drv/gbm.c                   | 185 +++++++++++++++++++
 dlls/winewayland.drv/options.c               |   4 +
 dlls/winewayland.drv/wayland_native_buffer.c |  51 +++++
 dlls/winewayland.drv/waylanddrv.h            |  11 ++
 include/config.h.in                          |   3 +
 8 files changed, 342 insertions(+), 2 deletions(-)
 create mode 100644 dlls/winewayland.drv/gbm.c

diff --git a/configure b/configure
index 0df6d7128c7..fdf9b84abcf 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,8 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+GBM_LIBS
+GBM_CFLAGS
 DRM_LIBS
 DRM_CFLAGS
 XKBCOMMON_LIBS
@@ -1720,6 +1722,8 @@ WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS
 XKBCOMMON_CFLAGS
 XKBCOMMON_LIBS
+GBM_CFLAGS
+GBM_LIBS
 DRM_CFLAGS
 DRM_LIBS
 INOTIFY_CFLAGS
@@ -2535,6 +2539,8 @@ Some influential environment variables:
               C compiler flags for xkbcommon, overriding pkg-config
   XKBCOMMON_LIBS
               Linker flags for xkbcommon, overriding pkg-config
+  GBM_CFLAGS  C compiler flags for gbm, overriding pkg-config
+  GBM_LIBS    Linker flags for gbm, overriding pkg-config
   DRM_CFLAGS  C compiler flags for libdrm, overriding pkg-config
   DRM_LIBS    Linker flags for libdrm, overriding pkg-config
   INOTIFY_CFLAGS
@@ -16082,6 +16088,78 @@ else $as_nop
   XKBCOMMON_LIBS=""
 fi
 
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${GBM_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GBM_CFLAGS=`$PKG_CONFIG --cflags gbm 2>/dev/null`
+fi
+fi
+
+if ${GBM_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  GBM_LIBS=`$PKG_CONFIG --libs gbm 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm cflags: $GBM_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: gbm libs: $GBM_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $GBM_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "gbm.h" "ac_cv_header_gbm_h" "$ac_includes_default"
+if test "x$ac_cv_header_gbm_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_GBM_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for gbm_create_device in -lgbm" >&5
+printf %s "checking for gbm_create_device in -lgbm... " >&6; }
+if test ${ac_cv_lib_gbm_gbm_create_device+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lgbm $GBM_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char gbm_create_device ();
+int
+main (void)
+{
+return gbm_create_device ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_gbm_gbm_create_device=yes
+else $as_nop
+  ac_cv_lib_gbm_gbm_create_device=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_gbm_gbm_create_device" >&5
+printf "%s\n" "$ac_cv_lib_gbm_gbm_create_device" >&6; }
+if test "x$ac_cv_lib_gbm_gbm_create_device" = xyes
+then :
+  :
+else $as_nop
+  GBM_LIBS=""
+fi
+
 CPPFLAGS=$ac_save_CPPFLAGS
 
     if ${DRM_CFLAGS:+false} :
@@ -16162,6 +16240,7 @@ if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_SCANNER" ||
                            test -z "$WAYLAND_CURSOR_LIBS" ||
                            test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
                            test -z "$DRM_LIBS"
 then :
   case "x$with_wayland" in
@@ -23697,6 +23776,8 @@ WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
 XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
 XKBCOMMON_LIBS = $XKBCOMMON_LIBS
+GBM_CFLAGS = $GBM_CFLAGS
+GBM_LIBS = $GBM_LIBS
 DRM_CFLAGS = $DRM_CFLAGS
 DRM_LIBS = $DRM_LIBS
 PCAP_LIBS = $PCAP_LIBS
diff --git a/configure.ac b/configure.ac
index ed6e37ce1ce..ab1dda6890d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1379,6 +1379,9 @@ then
     WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
         [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
          AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
+    WINE_PACKAGE_FLAGS(GBM,[gbm],,,,
+        [AC_CHECK_HEADERS([gbm.h])
+         AC_CHECK_LIB(gbm,gbm_create_device,[:],[GBM_LIBS=""],[$GBM_LIBS])])
     WINE_PACKAGE_FLAGS(DRM,[libdrm],,,,
         [AC_CHECK_HEADERS([drm.h])
          AC_CHECK_LIB(drm,drmPrimeHandleToFD,[:],[DRM_LIBS=""],[$DRM_LIBS])])
@@ -1388,6 +1391,7 @@ WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_SCANNER" ||
                            test -z "$WAYLAND_CURSOR_LIBS" ||
                            test -z "$XKBCOMMON_LIBS" ||
+                           test -z "$GBM_LIBS" ||
                            test -z "$DRM_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index 97674ebb599..5fcc27aec61 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -3,9 +3,9 @@ MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 IMPORTS = user32
 EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS) \
-            $(DRM_CFLAGS)
+            $(GBM_CFLAGS) $(UDEV_CFLAGS) $(DRM_CFLAGS)
 EXTRALIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
-             $(XKBCOMMON_LIBS) $(DRM_LIBS) $(PTHREAD_LIBS)
+            $(XKBCOMMON_LIBS) $(GBM_LIBS) $(UDEV_LIBS) $(DRM_LIBS) $(PTHREAD_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -14,6 +14,7 @@ EXTRACROSSCFLAGS = -std=c11 -Wno-declaration-after-statement
 C_SRCS = \
 	display.c \
 	dllmain.c \
+	gbm.c \
 	options.c \
 	registry.c \
 	unicode.c \
diff --git a/dlls/winewayland.drv/gbm.c b/dlls/winewayland.drv/gbm.c
new file mode 100644
index 00000000000..8123a014a59
--- /dev/null
+++ b/dlls/winewayland.drv/gbm.c
@@ -0,0 +1,185 @@
+/*
+ * Wayland GBM support
+ *
+ * Copyright 2022 Alexandros Frantzis for Collabora Ltd
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#include "config.h"
+
+#include "waylanddrv.h"
+#include "wine/debug.h"
+
+#include <errno.h>
+#include <fcntl.h>
+#ifdef HAVE_LIBUDEV_H
+#include <libudev.h>
+#endif
+#include <stdlib.h>
+#include <unistd.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
+
+struct gbm_device *process_gbm_device;
+static pthread_once_t init_once;
+
+static const char default_seat[] = "seat0";
+static const char default_render_node[] = "/dev/dri/renderD128";
+static const char default_primary_node[] = "/dev/dri/card0";
+static const char primary_node_sysname[] = "card[0-9]*";
+static const char render_node_sysname[] = "renderD[0-9]*";
+
+#ifdef HAVE_UDEV
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
+{
+    const char *seat;
+    struct udev *udev = NULL;
+    struct udev_enumerate *e = NULL;
+    struct udev_list_entry *entry;
+    int drm_fd = -1;
+
+    seat = getenv("XDG_SEAT");
+    if (!seat) seat = default_seat;
+
+    udev = udev_new();
+    if (!udev) goto out;
+
+    e = udev_enumerate_new(udev);
+    if (!e) goto out;
+    udev_enumerate_add_match_subsystem(e, "drm");
+    udev_enumerate_add_match_sysname(e, sysname);
+
+    udev_enumerate_scan_devices(e);
+    udev_list_entry_foreach(entry, udev_enumerate_get_list_entry(e))
+    {
+        const char *path, *device_seat, *devnode;
+        struct udev_device *device;
+
+        path = udev_list_entry_get_name(entry);
+        device = udev_device_new_from_syspath(udev, path);
+        if (!device) continue;
+
+        device_seat = udev_device_get_property_value(device, "ID_SEAT");
+        if (!device_seat) device_seat = default_seat;
+        if (strcmp(device_seat, seat))
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        devnode = udev_device_get_devnode(device);
+        if (!devnode)
+        {
+            udev_device_unref(device);
+            continue;
+        }
+
+        drm_fd = open(devnode, O_RDWR);
+        TRACE("Trying to open drm device (%s) %s => fd=%d\n", desc, devnode, drm_fd);
+
+        udev_device_unref(device);
+        if (drm_fd >= 0) break;
+    }
+
+out:
+    if (e) udev_enumerate_unref(e);
+    if (udev) udev_unref(udev);
+
+    return drm_fd;
+}
+
+#else
+
+static int wayland_gbm_get_drm_fd(const char *sysname, const char *desc)
+{
+    return -1;
+}
+
+#endif
+
+static void wayland_gbm_init_once(void)
+{
+    int drm_fd = -1;
+    const char *desc;
+
+    if (option_drm_device)
+    {
+        drm_fd = open(option_drm_device, O_RDWR);
+        TRACE("Trying to open drm device (from options) %s => fd=%d\n",
+              option_drm_device, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open device from DRMDevice driver option\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random render node";
+        drm_fd = wayland_gbm_get_drm_fd(render_node_sysname, desc);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_render_node, O_RDWR);
+        TRACE("Trying to open drm device (default render node) %s => fd=%d\n",
+              default_render_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default render node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        desc = "random primary node";
+        drm_fd = wayland_gbm_get_drm_fd(primary_node_sysname, desc);
+        if (drm_fd < 0)
+            WARN("Failed to find a suitable primary node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        drm_fd = open(default_primary_node, O_RDWR);
+        TRACE("Trying to open drm device (default primary node) %s => fd=%d\n",
+              default_primary_node, drm_fd);
+        if (drm_fd < 0)
+            WARN("Failed to open default primary node\n");
+    }
+
+    if (drm_fd < 0)
+    {
+        ERR("Failed to find a suitable drm device\n");
+        return;
+    }
+
+    process_gbm_device = gbm_create_device(drm_fd);
+    if (!process_gbm_device)
+    {
+        ERR("Failed to create gbm device (errno=%d)\n", errno);
+        close(drm_fd);
+    }
+}
+
+BOOL wayland_gbm_init(void)
+{
+    pthread_once(&init_once, wayland_gbm_init_once);
+
+    return process_gbm_device != NULL;
+}
diff --git a/dlls/winewayland.drv/options.c b/dlls/winewayland.drv/options.c
index 7f0b4b31e2c..09eee191e6e 100644
--- a/dlls/winewayland.drv/options.c
+++ b/dlls/winewayland.drv/options.c
@@ -41,6 +41,7 @@
  *              Config options
  */
 
+char *option_drm_device = NULL;
 BOOL option_use_system_cursors = TRUE;
 
 /***********************************************************************
@@ -95,6 +96,9 @@ void wayland_read_options_from_registry(void)
         }
     }
 
+    if (!get_config_key(hkey, appkey, "DRMDevice", REG_SZ, buffer, sizeof(buffer)))
+        option_drm_device = strdup(buffer);
+
     if (!get_config_key(hkey, appkey, "UseSystemCursors", REG_SZ, buffer, sizeof(buffer)))
         option_use_system_cursors = IS_OPTION_TRUE(buffer[0]);
 
diff --git a/dlls/winewayland.drv/wayland_native_buffer.c b/dlls/winewayland.drv/wayland_native_buffer.c
index 471c636c04a..1519e8bbb00 100644
--- a/dlls/winewayland.drv/wayland_native_buffer.c
+++ b/dlls/winewayland.drv/wayland_native_buffer.c
@@ -23,9 +23,13 @@
 #include "config.h"
 
 #include "waylanddrv.h"
+#include "wine/debug.h"
 
 #include <assert.h>
 #include <unistd.h>
+#include <xf86drm.h>
+
+WINE_DEFAULT_DEBUG_CHANNEL(waylanddrv);
 
 /**********************************************************************
  *          wayland_native_buffer_init_shm
@@ -59,6 +63,53 @@ BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
     return TRUE;
 }
 
+/**********************************************************************
+ *          wayland_native_buffer_init_gbm
+ *
+ * Initializes a native buffer from a gbm_bo.
+ */
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo)
+{
+    int i;
+
+    native->plane_count = gbm_bo_get_plane_count(bo);
+    native->width = gbm_bo_get_width(bo);
+    native->height = gbm_bo_get_height(bo);
+    native->format = gbm_bo_get_format(bo);
+    for (i = 0; i < ARRAY_SIZE(native->fds); i++)
+        native->fds[i] = -1;
+
+    for (i = 0; i < native->plane_count; i++)
+    {
+        int ret;
+        union gbm_bo_handle handle;
+
+        handle = gbm_bo_get_handle_for_plane(bo, i);
+        if (handle.s32 == -1)
+        {
+            ERR("error: failed to get gbm_bo_handle\n");
+            goto err;
+        }
+
+        ret = drmPrimeHandleToFD(gbm_device_get_fd(gbm_bo_get_device(bo)),
+                                 handle.u32, 0, &native->fds[i]);
+        if (ret < 0 || native->fds[i] < 0)
+        {
+            ERR("error: failed to get dmabuf_fd\n");
+            goto err;
+        }
+        native->strides[i] = gbm_bo_get_stride_for_plane(bo, i);
+        native->offsets[i] = gbm_bo_get_offset(bo, i);
+    }
+
+    return TRUE;
+
+err:
+    wayland_native_buffer_deinit(native);
+    return FALSE;
+}
+
 /**********************************************************************
  *          wayland_native_buffer_deinit
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0c9b5fda8a2..5172eb0cb0b 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -25,6 +25,7 @@
 # error You must include config.h to use this header
 #endif
 
+#include <gbm.h>
 #include <pthread.h>
 #include <sys/types.h>
 #include <stdarg.h>
@@ -52,8 +53,10 @@
  */
 
 extern struct wl_display *process_wl_display DECLSPEC_HIDDEN;
+extern struct gbm_device *process_gbm_device DECLSPEC_HIDDEN;
 extern NTSTATUS (WINAPI *pNtWaitForMultipleObjects)(ULONG,const HANDLE*,BOOLEAN,
                                                     BOOLEAN,const LARGE_INTEGER*) DECLSPEC_HIDDEN;
+extern char *option_drm_device DECLSPEC_HIDDEN;
 extern BOOL option_use_system_cursors DECLSPEC_HIDDEN;
 
 /**********************************************************************
@@ -434,6 +437,8 @@ int wayland_surface_get_buffer_scale(struct wayland_surface *surface) DECLSPEC_H
 BOOL wayland_native_buffer_init_shm(struct wayland_native_buffer *native,
                                     int width, int height,
                                     enum wl_shm_format format) DECLSPEC_HIDDEN;
+BOOL wayland_native_buffer_init_gbm(struct wayland_native_buffer *native,
+                                    struct gbm_bo *bo) DECLSPEC_HIDDEN;
 void wayland_native_buffer_deinit(struct wayland_native_buffer *native) DECLSPEC_HIDDEN;
 
 /**********************************************************************
@@ -514,6 +519,12 @@ BOOL wayland_init_set_cursor(void) DECLSPEC_HIDDEN;
 HCURSOR wayland_invalidate_set_cursor(void) DECLSPEC_HIDDEN;
 void wayland_set_cursor_if_current_invalid(HCURSOR hcursor) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          GBM support
+ */
+
+BOOL wayland_gbm_init(void) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Registry helpers
  */
diff --git a/include/config.h.in b/include/config.h.in
index 0dc23e19fdd..58f7ec6c3fd 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -92,6 +92,9 @@
 /* Define to 1 if you have the `futimesat' function. */
 #undef HAVE_FUTIMESAT
 
+/* Define to 1 if you have the <gbm.h> header file. */
+#undef HAVE_GBM_H
+
 /* Define to 1 if you have the `getaddrinfo' function. */
 #undef HAVE_GETADDRINFO
 
-- 
2.36.1

