From b8947a997b107741d070fad69a76b82feebbe308 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 10 Dec 2020 14:09:36 +0200
Subject: [PATCH 001/170] gdi32: Track ticks since draw start per
 window_surface.

Track ticks since draw start per window_surface, instead of per window
as is currently the case. This helps reduce visual glitches caused by
badly timed flushes in backends which use the same (parent)
window_surface for children windows.

For example, with a shared window_surface, and with the current scheme
of per window start_tick tracking, we may flush while drawing a child
when performing a redraw originating from the parent:

flush
Draw parent (bounds is empty so parent start_ticks is reset)
Draw child 1 (bounds possibly not empty, child1 start_ticks not reset,
              and, depending on when child 1 was drawn independently,
              this could lead to a flush during the draw)

With per surface draw ticks:

flush
Draw parent (bounds is empty so surface start_ticks is reset)
Draw child 1 (bounds possibly not empty, but since surface start_ticks
              was reset by the parent it's unlikely that we flush during
              this draw)

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/win32u/dibdrv/dc.c   | 7 ++++---
 include/wine/gdi_driver.h | 1 +
 2 files changed, 5 insertions(+), 3 deletions(-)

diff --git a/dlls/win32u/dibdrv/dc.c b/dlls/win32u/dibdrv/dc.c
index 7c60466d9ee..434b0cbf778 100644
--- a/dlls/win32u/dibdrv/dc.c
+++ b/dlls/win32u/dibdrv/dc.c
@@ -731,7 +731,6 @@ struct windrv_physdev
     struct gdi_physdev     dev;
     struct dibdrv_physdev *dibdrv;
     struct window_surface *surface;
-    DWORD                  start_ticks;
 };
 
 static const struct gdi_dc_funcs window_driver;
@@ -745,13 +744,15 @@ static inline void lock_surface( struct windrv_physdev *dev )
 {
     /* gdi_lock should not be locked */
     dev->surface->funcs->lock( dev->surface );
-    if (IsRectEmpty( dev->dibdrv->bounds )) dev->start_ticks = NtGetTickCount();
+    if (IsRectEmpty( dev->dibdrv->bounds ) || dev->surface->draw_start_ticks == 0)
+        dev->surface->draw_start_ticks = NtGetTickCount();
 }
 
 static inline void unlock_surface( struct windrv_physdev *dev )
 {
+    BOOL should_flush = NtGetTickCount() - dev->surface->draw_start_ticks > FLUSH_PERIOD;
     dev->surface->funcs->unlock( dev->surface );
-    if (NtGetTickCount() - dev->start_ticks > FLUSH_PERIOD) dev->surface->funcs->flush( dev->surface );
+    if (should_flush) dev->surface->funcs->flush( dev->surface );
 }
 
 static void CDECL unlock_bits_surface( struct gdi_image_bits *bits )
diff --git a/include/wine/gdi_driver.h b/include/wine/gdi_driver.h
index 998aa3ed3e9..d9a18ba312b 100644
--- a/include/wine/gdi_driver.h
+++ b/include/wine/gdi_driver.h
@@ -217,6 +217,7 @@ struct window_surface
     struct list                        entry; /* entry in global list managed by user32 */
     LONG                               ref;   /* reference count */
     RECT                               rect;  /* constant, no locking needed */
+    DWORD                              draw_start_ticks; /* start ticks of fresh draw */
     /* driver-specific fields here */
 };
 
-- 
2.36.1

