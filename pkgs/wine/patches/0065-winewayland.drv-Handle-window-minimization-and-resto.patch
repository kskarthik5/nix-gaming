From 0d00ee119d1641742c839cc4076646199575e1e1 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 8 Sep 2021 12:40:58 +0300
Subject: [PATCH 065/170] winewayland.drv: Handle window minimization and
 restoration.

Request a minimized state from the Wayland compositor when a window
is minimized.

Since Wayland doesn't provide any explicit information about the
minimization state of surfaces, we heurestically infer a restoration
from a minimized state by using the keyboard focus of the surface.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_keyboard.c | 15 ++++++++++++
 dlls/winewayland.drv/waylanddrv.h       |  1 +
 dlls/winewayland.drv/waylanddrv_main.c  |  1 +
 dlls/winewayland.drv/window.c           | 32 +++++++++++++++++++++++--
 4 files changed, 47 insertions(+), 2 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
index d666a8b7b4a..6442651e6b4 100644
--- a/dlls/winewayland.drv/wayland_keyboard.c
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -773,6 +773,21 @@ static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
         {
             struct wayland_surface *toplevel = wayland_surface;
             while (toplevel->parent) toplevel = toplevel->parent;
+
+            if (NtUserGetWindowLongW( toplevel->hwnd, GWL_STYLE ) & WS_MINIMIZE)
+            {
+                /* If a minimized window is already activated from Wine's
+                 * perspective, reactivating it is a null operation, and thus
+                 * won't trigger any activation side-effects (e.g., many games
+                 * change the display mode when they are activated). In order
+                 * to get those effects properly applied, deactivate the window
+                 * now, so it can be properly reactivated after restoration. */
+                if (foreground == toplevel->hwnd)
+                    NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+                NtUserShowWindow(toplevel->hwnd, SW_RESTORE);
+                NtUserShowOwnedPopups(toplevel->hwnd, TRUE);
+            }
+
             NtUserSetForegroundWindow(toplevel->hwnd);
         }
     }
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0602998e8fa..03fad0f6019 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -511,6 +511,7 @@ NTSTATUS WAYLAND_MsgWaitForMultipleObjectsEx(DWORD count, const HANDLE *handles,
                                              const LARGE_INTEGER *timeout,
                                              DWORD mask, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_SetCursor(HCURSOR hcursor) DECLSPEC_HIDDEN;
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp) DECLSPEC_HIDDEN;
 INT WAYLAND_ToUnicodeEx(UINT virt, UINT scan, const BYTE *state,
                         LPWSTR buf, int nchars, UINT flags, HKL hkl) DECLSPEC_HIDDEN;
 void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index 421b9624ba6..2302eb5fe12 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -140,6 +140,7 @@ static const struct user_driver_funcs waylanddrv_funcs =
     .pMapVirtualKeyEx = WAYLAND_MapVirtualKeyEx,
     .pMsgWaitForMultipleObjectsEx = WAYLAND_MsgWaitForMultipleObjectsEx,
     .pSetCursor = WAYLAND_SetCursor,
+    .pShowWindow = WAYLAND_ShowWindow,
     .pToUnicodeEx = WAYLAND_ToUnicodeEx,
     .pVkKeyScanEx = WAYLAND_VkKeyScanEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 101cd8b7942..96b634811bc 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -975,6 +975,32 @@ void WAYLAND_WindowPosChanged(HWND hwnd, HWND insert_after, UINT swp_flags,
     wayland_win_data_release(data);
 }
 
+/***********************************************************************
+ *           WAYLAND_ShowWindow
+ */
+UINT WAYLAND_ShowWindow(HWND hwnd, INT cmd, RECT *rect, UINT swp)
+{
+    struct wayland_surface *wsurface;
+
+    TRACE("hwnd=%p cmd=%d\n", hwnd, cmd);
+
+    if (IsRectEmpty(rect)) return swp;
+    if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE)) return swp;
+    /* always hide icons off-screen */
+    if (rect->left != -32000 || rect->top != -32000)
+    {
+        OffsetRect(rect, -32000 - rect->left, -32000 - rect->top);
+        swp &= ~(SWP_NOMOVE | SWP_NOCLIENTMOVE);
+    }
+
+    if ((wsurface = wayland_surface_for_hwnd_lock(hwnd)) && wsurface->xdg_toplevel)
+        xdg_toplevel_set_minimized(wsurface->xdg_toplevel);
+
+    wayland_surface_for_hwnd_unlock(wsurface);
+
+    return swp;
+}
+
 static void handle_wm_wayland_monitor_change(struct wayland *wayland)
 {
     wayland_update_outputs_from_process(wayland);
@@ -1027,7 +1053,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (width == 0)
     {
         int ignore;
-        width = data->restore_rect.right - data->restore_rect.left;
+        if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE))
+            width = data->restore_rect.right - data->restore_rect.left;
         if (width == 0)
             width = data->window_rect.right - data->window_rect.left;
         wayland_surface_coords_rounded_from_wine(wsurface, width, 0,
@@ -1037,7 +1064,8 @@ static LRESULT handle_wm_wayland_configure(HWND hwnd)
     if (height == 0)
     {
         int ignore;
-        height = data->restore_rect.bottom - data->restore_rect.top;
+        if (!(NtUserGetWindowLongW(hwnd, GWL_STYLE) & WS_MINIMIZE))
+            height = data->restore_rect.bottom - data->restore_rect.top;
         if (height == 0)
             height = data->window_rect.bottom - data->window_rect.top;
         wayland_surface_coords_rounded_from_wine(wsurface, 0, height,
-- 
2.36.1

