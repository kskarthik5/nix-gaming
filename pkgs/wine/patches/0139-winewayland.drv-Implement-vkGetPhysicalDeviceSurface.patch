From 15630bc80f7026ec59e853f886816814166db545 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 20 Sep 2021 12:27:03 +0300
Subject: [PATCH 139/170] winewayland.drv: Implement
 vkGetPhysicalDeviceSurfaceFormats(2)KHR.

Passthrough implementations with two additions:

1. Checking for invalidated VkSurfaceKHR.
2. Try to emulate vkGetPhysicalDeviceSurfaceFormats2KHR with
   vkGetPhysicalDeviceSurfaceFormatsKHR if needed.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/vulkan.c | 66 +++++++++++++++++++++++++++++++++++
 1 file changed, 66 insertions(+)

diff --git a/dlls/winewayland.drv/vulkan.c b/dlls/winewayland.drv/vulkan.c
index 017903e6c70..ba0da3ea2c4 100644
--- a/dlls/winewayland.drv/vulkan.c
+++ b/dlls/winewayland.drv/vulkan.c
@@ -67,6 +67,8 @@ static void * (*pvkGetInstanceProcAddr)(VkInstance, const char *);
 static VkResult (*pvkGetPhysicalDevicePresentRectanglesKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkRect2D *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilities2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, VkSurfaceCapabilities2KHR *);
 static VkResult (*pvkGetPhysicalDeviceSurfaceCapabilitiesKHR)(VkPhysicalDevice, VkSurfaceKHR, VkSurfaceCapabilitiesKHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormats2KHR)(VkPhysicalDevice, const VkPhysicalDeviceSurfaceInfo2KHR *, uint32_t *, VkSurfaceFormat2KHR *);
+static VkResult (*pvkGetPhysicalDeviceSurfaceFormatsKHR)(VkPhysicalDevice, VkSurfaceKHR, uint32_t *, VkSurfaceFormatKHR *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
 
 static void *vulkan_handle;
@@ -607,6 +609,66 @@ static VkResult wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR(VkPhysicalDevi
     return res;
 }
 
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormats2KHR(VkPhysicalDevice phys_dev,
+                                                              const VkPhysicalDeviceSurfaceInfo2KHR *surface_info,
+                                                              uint32_t *count,
+                                                              VkSurfaceFormat2KHR *formats)
+{
+    VkSurfaceFormatKHR *formats_host;
+    uint32_t i;
+    VkResult result;
+    TRACE("%p, %p, %p, %p\n", phys_dev, surface_info, count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface_info->surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    if (pvkGetPhysicalDeviceSurfaceFormats2KHR)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormats2KHR(phys_dev, surface_info,
+                                                      count, formats);
+    }
+
+    /* Until the loader version exporting this function is common, emulate it
+     * using the older non-2 version. */
+    if (surface_info->pNext)
+    {
+        FIXME("Emulating vkGetPhysicalDeviceSurfaceFormats2KHR with "
+              "vkGetPhysicalDeviceSurfaceFormatsKHR, pNext is ignored.\n");
+    }
+
+    if (!formats)
+    {
+        return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                     count, NULL);
+    }
+
+    formats_host = calloc(*count, sizeof(*formats_host));
+    if (!formats_host) return VK_ERROR_OUT_OF_HOST_MEMORY;
+    result = pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface_info->surface,
+                                                   count, formats_host);
+    if (result == VK_SUCCESS || result == VK_INCOMPLETE)
+    {
+        for (i = 0; i < *count; i++)
+            formats[i].surfaceFormat = formats_host[i];
+    }
+
+    free(formats_host);
+    return result;
+}
+
+static VkResult wayland_vkGetPhysicalDeviceSurfaceFormatsKHR(VkPhysicalDevice phys_dev,
+                                                             VkSurfaceKHR surface,
+                                                             uint32_t *count,
+                                                             VkSurfaceFormatKHR *formats)
+{
+    TRACE("%p, 0x%s, %p, %p\n", phys_dev, wine_dbgstr_longlong(surface), count, formats);
+
+    if (!wine_vk_surface_handle_is_valid(surface))
+        RETURN_VK_ERROR_SURFACE_LOST_KHR;
+
+    return pvkGetPhysicalDeviceSurfaceFormatsKHR(phys_dev, surface, count, formats);
+}
+
 static VkResult validate_present_info(const VkPresentInfoKHR *present_info)
 {
     uint32_t i;
@@ -724,6 +786,8 @@ static void wine_vk_init(void)
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDevicePresentRectanglesKHR);
     LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilities2KHR);
     LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceCapabilitiesKHR);
+    LOAD_OPTIONAL_FUNCPTR(vkGetPhysicalDeviceSurfaceFormats2KHR);
+    LOAD_FUNCPTR(vkGetPhysicalDeviceSurfaceFormatsKHR);
     LOAD_FUNCPTR(vkQueuePresentKHR);
 #undef LOAD_FUNCPTR
 #undef LOAD_OPTIONAL_FUNCPTR
@@ -750,6 +814,8 @@ static const struct vulkan_funcs vulkan_funcs =
     .p_vkGetPhysicalDevicePresentRectanglesKHR = wayland_vkGetPhysicalDevicePresentRectanglesKHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilities2KHR = wayland_vkGetPhysicalDeviceSurfaceCapabilities2KHR,
     .p_vkGetPhysicalDeviceSurfaceCapabilitiesKHR = wayland_vkGetPhysicalDeviceSurfaceCapabilitiesKHR,
+    .p_vkGetPhysicalDeviceSurfaceFormats2KHR = wayland_vkGetPhysicalDeviceSurfaceFormats2KHR,
+    .p_vkGetPhysicalDeviceSurfaceFormatsKHR = wayland_vkGetPhysicalDeviceSurfaceFormatsKHR,
     .p_vkQueuePresentKHR = wayland_vkQueuePresentKHR,
 };
 
-- 
2.36.1

