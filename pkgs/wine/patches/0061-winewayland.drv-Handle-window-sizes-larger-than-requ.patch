From 792b8a628d20b76bc615f25a62caa5f4a21be6b2 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Wed, 17 Nov 2021 18:12:25 +0200
Subject: [PATCH 061/170] winewayland.drv: Handle window sizes larger than
 required by Wayland.

If the application provides a window larger than what is required by the
current Wayland state, use only the portion of the window visible on its
main monitor to keep Wayland from issuing a protocol error.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 14 ++---
 dlls/winewayland.drv/window.c          | 78 +++++++++++++++++++++++++-
 2 files changed, 83 insertions(+), 9 deletions(-)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 9bc207979ba..cfce5924bfc 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -378,20 +378,18 @@ BOOL wayland_surface_configure_is_compatible(struct wayland_surface_configure *c
     if ((flags & mask) != (conf->configure_flags & mask))
         return FALSE;
 
-    /* The maximized state requires the configured size. */
+    /* The maximized state requires the configured size. During surface
+     * reconfiguration we can use surface geometry to provide smaller areas
+     * from larger sizes, so only smaller sizes are incompatible. */
     if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) &&
-        (width != conf->width || height != conf->height))
+        (width < conf->width || height < conf->height))
     {
         return FALSE;
     }
 
     /* The fullscreen state requires sizes smaller or equal to the configured
-     * size. */
-    if ((conf->configure_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
-        (width > conf->width || height > conf->height))
-    {
-        return FALSE;
-    }
+     * size. We can provide this during surface reconfiguration using surface
+     * geometry, so we are always compatible with a fullscreen state. */
 
     return TRUE;
 }
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index b3b8b45dc26..ee477e0a0b9 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -666,6 +666,78 @@ static BOOL wayland_win_data_update_wayland_xdg_state(struct wayland_win_data *d
     return TRUE;
 }
 
+static void wayland_win_data_get_rect_in_monitor(struct wayland_win_data *data,
+                                                 enum wayland_configure_flags flags,
+                                                 RECT *rect)
+{
+    HMONITOR hmonitor;
+    MONITORINFO mi;
+    RECT *area = NULL;
+
+    mi.cbSize = sizeof(mi);
+    if ((hmonitor = NtUserMonitorFromWindow(data->hwnd, MONITOR_DEFAULTTOPRIMARY)) &&
+        NtUserGetMonitorInfo(hmonitor, (MONITORINFO *)&mi))
+    {
+        if (flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)
+            area = &mi.rcMonitor;
+        else if (flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED)
+            area = &mi.rcWork;
+    }
+
+    if (area)
+    {
+        intersect_rect(rect, area, &data->window_rect);
+        OffsetRect(rect, -data->window_rect.left, -data->window_rect.top);
+    }
+    else
+    {
+        SetRectEmpty(rect);
+    }
+}
+
+static void wayland_win_data_get_compatible_rect(struct wayland_win_data *data,
+                                                 RECT *rect)
+{
+    int width = data->window_rect.right - data->window_rect.left;
+    int height = data->window_rect.bottom - data->window_rect.top;
+    int wine_conf_width, wine_conf_height;
+    enum wayland_configure_flags conf_flags =
+        data->wayland_surface->current.configure_flags;
+
+    /* Get the window size corresponding to the Wayland surfaces configuration. */
+    wayland_surface_coords_to_wine(data->wayland_surface,
+                                   data->wayland_surface->current.width,
+                                   data->wayland_surface->current.height,
+                                   &wine_conf_width,
+                                   &wine_conf_height);
+
+    /* If Wayland requires a surface size smaller than what wine provides,
+     * use part of the window contents for the surface. */
+    if (((conf_flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED) ||
+         (conf_flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN)) &&
+        (width > wine_conf_width || height > wine_conf_height))
+    {
+        wayland_win_data_get_rect_in_monitor(data, conf_flags, rect);
+        /* If the window rect in the monitor is smaller than required
+         * fall back to an appropriately sized rect at the top-left. */
+        if (rect->right - rect->left < wine_conf_width ||
+            rect->bottom - rect->top < wine_conf_height)
+        {
+            SetRect(rect, 0, 0, wine_conf_width, wine_conf_height);
+        }
+        else
+        {
+            rect->right = min(rect->right, rect->left + wine_conf_width);
+            rect->bottom = min(rect->bottom, rect->top + wine_conf_height);
+        }
+        TRACE("Window is too large for wayland state, using subarea\n");
+    }
+    else
+    {
+        SetRect(rect, 0, 0, width, height);
+    }
+}
+
 static void wayland_win_data_update_wayland_surface_state(struct wayland_win_data *data)
 {
     RECT screen_rect;
@@ -711,7 +783,11 @@ static void wayland_win_data_update_wayland_surface_state(struct wayland_win_dat
     }
     else if (wsurface->xdg_surface)
     {
-        wayland_surface_reconfigure_geometry(wsurface, 0, 0, width, height);
+        RECT compat;
+        wayland_win_data_get_compatible_rect(data, &compat);
+        wayland_surface_reconfigure_geometry(wsurface, compat.left, compat.top,
+                                             compat.right - compat.left,
+                                             compat.bottom - compat.top);
     }
 
     wayland_surface_reconfigure_apply(wsurface);
-- 
2.36.1

