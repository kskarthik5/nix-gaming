From cb620d8be11c9f864c9b607b784b86dc41180170 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Mon, 6 Sep 2021 13:24:54 +0300
Subject: [PATCH 050/170] winewayland.drv: Basic handling of Wayland keyboard
 events.

Handle Wayland keyboard events and translate them to Windows events,
currently using a hardcoded US key mapping.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 configure                                     |  85 +++-
 configure.ac                                  |   6 +-
 dlls/winewayland.drv/Makefile.in              |   5 +-
 dlls/winewayland.drv/wayland.c                |  12 +
 dlls/winewayland.drv/wayland_keyboard.c       | 397 ++++++++++++++++++
 .../winewayland.drv/wayland_keyboard_layout.h | 287 +++++++++++++
 dlls/winewayland.drv/wayland_surface.c        |   4 +
 dlls/winewayland.drv/waylanddrv.h             |  30 ++
 dlls/winewayland.drv/window.c                 |   9 +
 include/config.h.in                           |   3 +
 10 files changed, 834 insertions(+), 4 deletions(-)
 create mode 100644 dlls/winewayland.drv/wayland_keyboard.c
 create mode 100644 dlls/winewayland.drv/wayland_keyboard_layout.h

diff --git a/configure b/configure
index 6dd1711bbc9..a15a2483fe1 100755
--- a/configure
+++ b/configure
@@ -701,6 +701,8 @@ DBUS_CFLAGS
 INOTIFY_LIBS
 INOTIFY_CFLAGS
 PCAP_LIBS
+XKBCOMMON_LIBS
+XKBCOMMON_CFLAGS
 WAYLAND_CURSOR_LIBS
 WAYLAND_CURSOR_CFLAGS
 WAYLAND_SCANNER
@@ -1714,6 +1716,8 @@ WAYLAND_PROTOCOLS_CFLAGS
 WAYLAND_PROTOCOLS_LIBS
 WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS
 INOTIFY_CFLAGS
 INOTIFY_LIBS
 DBUS_CFLAGS
@@ -2523,6 +2527,10 @@ Some influential environment variables:
               C compiler flags for wayland-cursor, overriding pkg-config
   WAYLAND_CURSOR_LIBS
               Linker flags for wayland-cursor, overriding pkg-config
+  XKBCOMMON_CFLAGS
+              C compiler flags for xkbcommon, overriding pkg-config
+  XKBCOMMON_LIBS
+              Linker flags for xkbcommon, overriding pkg-config
   INOTIFY_CFLAGS
               C compiler flags for libinotify, overriding pkg-config
   INOTIFY_LIBS
@@ -15996,13 +16004,86 @@ else $as_nop
   WAYLAND_CURSOR_LIBS=""
 fi
 
+CPPFLAGS=$ac_save_CPPFLAGS
+
+    if ${XKBCOMMON_CFLAGS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_CFLAGS=`$PKG_CONFIG --cflags xkbcommon 2>/dev/null`
+fi
+fi
+
+if ${XKBCOMMON_LIBS:+false} :
+then :
+  if test ${PKG_CONFIG+y}
+then :
+  XKBCOMMON_LIBS=`$PKG_CONFIG --libs xkbcommon 2>/dev/null`
+fi
+fi
+
+
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon cflags: $XKBCOMMON_CFLAGS" >&5
+printf "%s\n" "$as_me:${as_lineno-$LINENO}: xkbcommon libs: $XKBCOMMON_LIBS" >&5
+ac_save_CPPFLAGS=$CPPFLAGS
+CPPFLAGS="$CPPFLAGS $XKBCOMMON_CFLAGS"
+ac_fn_c_check_header_compile "$LINENO" "xkbcommon/xkbcommon.h" "ac_cv_header_xkbcommon_xkbcommon_h" "$ac_includes_default"
+if test "x$ac_cv_header_xkbcommon_xkbcommon_h" = xyes
+then :
+  printf "%s\n" "#define HAVE_XKBCOMMON_XKBCOMMON_H 1" >>confdefs.h
+
+fi
+
+         { printf "%s\n" "$as_me:${as_lineno-$LINENO}: checking for xkb_context_new in -lxkbcommon" >&5
+printf %s "checking for xkb_context_new in -lxkbcommon... " >&6; }
+if test ${ac_cv_lib_xkbcommon_xkb_context_new+y}
+then :
+  printf %s "(cached) " >&6
+else $as_nop
+  ac_check_lib_save_LIBS=$LIBS
+LIBS="-lxkbcommon $XKBCOMMON_LIBS $LIBS"
+cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+/* Override any GCC internal prototype to avoid an error.
+   Use char because int might match the return type of a GCC
+   builtin and then its argument prototype would still apply.  */
+char xkb_context_new ();
+int
+main (void)
+{
+return xkb_context_new ();
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_link "$LINENO"
+then :
+  ac_cv_lib_xkbcommon_xkb_context_new=yes
+else $as_nop
+  ac_cv_lib_xkbcommon_xkb_context_new=no
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.beam \
+    conftest$ac_exeext conftest.$ac_ext
+LIBS=$ac_check_lib_save_LIBS
+fi
+{ printf "%s\n" "$as_me:${as_lineno-$LINENO}: result: $ac_cv_lib_xkbcommon_xkb_context_new" >&5
+printf "%s\n" "$ac_cv_lib_xkbcommon_xkb_context_new" >&6; }
+if test "x$ac_cv_lib_xkbcommon_xkb_context_new" = xyes
+then :
+  :
+else $as_nop
+  XKBCOMMON_LIBS=""
+fi
+
 CPPFLAGS=$ac_save_CPPFLAGS
 
 fi
 if test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
                            test -z "$WAYLAND_SCANNER" ||
-                           test -z "$WAYLAND_CURSOR_LIBS"
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS"
 then :
   case "x$with_wayland" in
   x)   as_fn_append wine_notices "|Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported." ;;
@@ -23535,6 +23616,8 @@ WAYLAND_PROTOCOLS_DATADIR = $WAYLAND_PROTOCOLS_DATADIR
 WAYLAND_SCANNER = $WAYLAND_SCANNER
 WAYLAND_CURSOR_CFLAGS = $WAYLAND_CURSOR_CFLAGS
 WAYLAND_CURSOR_LIBS = $WAYLAND_CURSOR_LIBS
+XKBCOMMON_CFLAGS = $XKBCOMMON_CFLAGS
+XKBCOMMON_LIBS = $XKBCOMMON_LIBS
 PCAP_LIBS = $PCAP_LIBS
 INOTIFY_CFLAGS = $INOTIFY_CFLAGS
 INOTIFY_LIBS = $INOTIFY_LIBS
diff --git a/configure.ac b/configure.ac
index 668321e434f..8768af8397a 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1376,11 +1376,15 @@ then
         [AC_CHECK_HEADERS([wayland-cursor.h])
          AC_CHECK_LIB(wayland-cursor,wl_cursor_theme_load,[:],
                       [WAYLAND_CURSOR_LIBS=""],[$WAYLAND_CURSOR_LIBS])])
+    WINE_PACKAGE_FLAGS(XKBCOMMON,[xkbcommon],,,,
+        [AC_CHECK_HEADERS([xkbcommon/xkbcommon.h])
+         AC_CHECK_LIB(xkbcommon,xkb_context_new,[:],[XKBCOMMON_LIBS=""],[$XKBCOMMON_LIBS])])
 fi
 WINE_NOTICE_WITH(wayland, [test -z "$WAYLAND_CLIENT_LIBS" ||
                            test -z "$WAYLAND_PROTOCOLS_DATADIR" ||
                            test -z "$WAYLAND_SCANNER" ||
-                           test -z "$WAYLAND_CURSOR_LIBS"],
+                           test -z "$WAYLAND_CURSOR_LIBS" ||
+                           test -z "$XKBCOMMON_LIBS"],
                  [Wayland ${notice_platform}development files not found or not new enough, the Wayland driver won't be supported.],
                  [enable_winewayland_drv])
 
diff --git a/dlls/winewayland.drv/Makefile.in b/dlls/winewayland.drv/Makefile.in
index f7385b682ba..7a83d0c3312 100644
--- a/dlls/winewayland.drv/Makefile.in
+++ b/dlls/winewayland.drv/Makefile.in
@@ -2,9 +2,9 @@ EXTRADEFS = -DWINE_NO_LONG_TYPES
 MODULE = winewayland.drv
 UNIXLIB = winewayland.so
 IMPORTS = user32
-EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS)
+EXTRAINCL = $(WAYLAND_CLIENT_CFLAGS) $(WAYLAND_CURSOR_CFLAGS) $(XKBCOMMON_CFLAGS)
 EXTRALIBS = -lwin32u -lm $(WAYLAND_CLIENT_LIBS) $(WAYLAND_CURSOR_LIBS) \
-             $(PTHREAD_LIBS)
+             $(XKBCOMMON_LIBS) $(PTHREAD_LIBS)
 CFLAGS = -std=c11 -Wno-declaration-after-statement
 EXTRACFLAGS = -std=c11 -Wno-declaration-after-statement
 CPPFLAGS = -std=c11 -Wno-declaration-after-statement
@@ -19,6 +19,7 @@ C_SRCS = \
 	wayland.c \
 	wayland_buffer_queue.c \
 	wayland_cursor.c \
+	wayland_keyboard.c \
 	wayland_mutex.c \
 	wayland_native_buffer.c \
 	wayland_output.c \
diff --git a/dlls/winewayland.drv/wayland.c b/dlls/winewayland.drv/wayland.c
index ad79202dd4f..b3f97e29f0f 100644
--- a/dlls/winewayland.drv/wayland.c
+++ b/dlls/winewayland.drv/wayland.c
@@ -81,6 +81,15 @@ static void seat_handle_capabilities(void *data, struct wl_seat *seat,
     {
         wayland_pointer_deinit(&wayland->pointer);
     }
+
+    if ((caps & WL_SEAT_CAPABILITY_KEYBOARD) && !wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_init(&wayland->keyboard, wayland, wl_seat_get_keyboard(seat));
+    }
+    else if (!(caps & WL_SEAT_CAPABILITY_KEYBOARD) && wayland->keyboard.wl_keyboard)
+    {
+        wayland_keyboard_deinit(&wayland->keyboard);
+    }
 }
 
 static void seat_handle_name(void *data, struct wl_seat *seat, const char *name)
@@ -302,6 +311,9 @@ void wayland_deinit(struct wayland *wayland)
     if (wayland->pointer.wl_pointer)
         wayland_pointer_deinit(&wayland->pointer);
 
+    if (wayland->keyboard.wl_keyboard)
+        wayland_keyboard_deinit(&wayland->keyboard);
+
     if (wayland->wl_seat)
         wl_seat_destroy(wayland->wl_seat);
 
diff --git a/dlls/winewayland.drv/wayland_keyboard.c b/dlls/winewayland.drv/wayland_keyboard.c
new file mode 100644
index 00000000000..560b7ed7463
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard.c
@@ -0,0 +1,397 @@
+/*
+ * Keyboard related functions
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove KÃ¥ven
+ * Copyright 2011, 2012, 2013 Ken Thomases for CodeWeavers Inc.
+ * Copyright 2013 Alexandre Julliard
+ * Copyright 2015 Josh DuBois for CodeWeavers Inc.
+ * Copyright 2020 Alexandros Frantzis for Collabora Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#if 0
+#pragma makedep unix
+#endif
+
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
+#include "config.h"
+
+#include "waylanddrv.h"
+
+#include "wine/debug.h"
+
+#include "ntuser.h"
+
+#include <linux/input.h>
+#include <unistd.h>
+
+#include "wayland_keyboard_layout.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(keyboard);
+WINE_DECLARE_DEBUG_CHANNEL(key);
+
+static DWORD _xkb_keycode_to_scancode(struct wayland_keyboard *keyboard,
+                                      xkb_keycode_t xkb_keycode)
+{
+    /* Use linux input keycode as scan code for now. */
+    return xkb_keycode - 8;
+}
+
+static UINT _xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                 xkb_keycode_t xkb_keycode)
+{
+    return xkb_keycode < ARRAY_SIZE(xkb_keycode_to_vkey_us) ?
+           xkb_keycode_to_vkey_us[xkb_keycode] : 0;
+}
+
+/* xkb keycodes are offset by 8 from linux input keycodes. */
+static inline xkb_keycode_t linux_input_keycode_to_xkb(uint32_t key)
+{
+    return key + 8;
+}
+
+static void send_keyboard_input(HWND hwnd, WORD vkey, WORD scan, DWORD flags)
+{
+    INPUT input;
+
+    input.type             = INPUT_KEYBOARD;
+    input.u.ki.wVk         = vkey;
+    input.u.ki.wScan       = scan;
+    input.u.ki.dwFlags     = flags;
+    input.u.ki.time        = 0;
+    input.u.ki.dwExtraInfo = 0;
+
+    __wine_send_input(hwnd, &input, NULL);
+}
+
+static BOOL _xkb_keycode_is_keypad_num(xkb_keycode_t xkb_keycode)
+{
+    switch (xkb_keycode - 8)
+    {
+    case KEY_KP0: case KEY_KP1: case KEY_KP2: case KEY_KP3:
+    case KEY_KP4: case KEY_KP5: case KEY_KP6: case KEY_KP7:
+    case KEY_KP8: case KEY_KP9: case KEY_KPDOT:
+        return TRUE;
+    default:
+        return FALSE;
+    }
+}
+
+/* Get the vkey corresponding to an xkb keycode, potentially translating it to
+ * take into account the current keyboard state. */
+static UINT translate_xkb_keycode_to_vkey(struct wayland_keyboard *keyboard,
+                                          xkb_keycode_t xkb_keycode)
+{
+    UINT vkey = _xkb_keycode_to_vkey(keyboard, xkb_keycode);
+
+    if (_xkb_keycode_is_keypad_num(xkb_keycode) &&
+        xkb_state_mod_name_is_active(keyboard->xkb_state, XKB_MOD_NAME_NUM,
+                                     XKB_STATE_MODS_EFFECTIVE))
+    {
+        switch (vkey)
+        {
+        case VK_INSERT: vkey = VK_NUMPAD0; break;
+        case VK_END: vkey = VK_NUMPAD1; break;
+        case VK_DOWN: vkey = VK_NUMPAD2; break;
+        case VK_NEXT: vkey = VK_NUMPAD3; break;
+        case VK_LEFT: vkey = VK_NUMPAD4; break;
+        case VK_CLEAR: vkey = VK_NUMPAD5; break;
+        case VK_RIGHT: vkey = VK_NUMPAD6; break;
+        case VK_HOME: vkey = VK_NUMPAD7; break;
+        case VK_UP: vkey = VK_NUMPAD8; break;
+        case VK_PRIOR: vkey = VK_NUMPAD9; break;
+        case VK_DELETE: vkey = VK_DECIMAL; break;
+        default: break;
+        }
+    }
+    else if (vkey == VK_PAUSE &&
+             xkb_state_mod_name_is_active(keyboard->xkb_state,
+                                          XKB_MOD_NAME_CTRL,
+                                          XKB_STATE_MODS_EFFECTIVE))
+    {
+        vkey = VK_CANCEL;
+    }
+
+    return vkey;
+}
+
+static void wayland_keyboard_emit(struct wayland_keyboard *keyboard, uint32_t key,
+                                  uint32_t state, HWND hwnd)
+{
+    xkb_keycode_t xkb_keycode = linux_input_keycode_to_xkb(key);
+    UINT vkey = translate_xkb_keycode_to_vkey(keyboard, xkb_keycode);
+    UINT scan = _xkb_keycode_to_scancode(keyboard, xkb_keycode);
+    DWORD flags;
+
+    TRACE_(key)("xkb_keycode=%u vkey=0x%x scan=0x%x state=%d hwnd=%p\n",
+                xkb_keycode, vkey, scan, state, hwnd);
+
+    if (vkey == 0) return;
+
+    flags = 0;
+    if (state == WL_KEYBOARD_KEY_STATE_RELEASED) flags |= KEYEVENTF_KEYUP;
+    if (scan & 0xff00) flags |= KEYEVENTF_EXTENDEDKEY;
+
+    send_keyboard_input(hwnd, vkey, scan & 0xff, flags);
+}
+
+/**********************************************************************
+ *          Keyboard handling
+ */
+
+static void keyboard_handle_keymap(void *data, struct wl_keyboard *keyboard,
+                                   uint32_t format, int fd, uint32_t size)
+{
+    close(fd);
+}
+
+static BOOL wayland_surface_for_window_is_mapped(HWND hwnd)
+{
+    DWORD_PTR res;
+
+    if (!hwnd) return FALSE;
+
+    if (!send_message_timeout(hwnd, WM_WAYLAND_QUERY_SURFACE_MAPPED,
+                              0, 0, SMTO_BLOCK, 50, &res))
+    {
+        return FALSE;
+    }
+
+    return res;
+}
+
+static void keyboard_handle_enter(void *data, struct wl_keyboard *keyboard,
+                                  uint32_t serial, struct wl_surface *surface,
+                                  struct wl_array *keys)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *wayland_surface =
+        surface ? wl_surface_get_user_data(surface) : NULL;
+
+    /* Since keyboard events can arrive in multiple threads, ensure we only
+     * handle them in the thread that owns the surface, to avoid passing
+     * duplicate events to Wine. */
+    if (wayland_surface && wayland_surface->hwnd &&
+        wayland_surface->wayland == wayland)
+    {
+        HWND foreground = NtUserGetForegroundWindow();
+        BOOL foreground_is_mapped;
+
+        if (foreground == NtUserGetDesktopWindow()) foreground = NULL;
+        foreground_is_mapped = wayland_surface_for_window_is_mapped(foreground);
+
+        TRACE("surface=%p hwnd=%p foreground=%p foreground_is_mapped=%d\n",
+              wayland_surface, wayland_surface->hwnd, foreground,
+              foreground_is_mapped);
+
+        wayland->keyboard.focused_surface = wayland_surface;
+        wayland->keyboard.enter_serial = serial;
+
+        /* If the foreground window is not mapped, it may not have had the
+         * chance to acquire the keyboard focus. If we change the foreground
+         * window now, we may cause side effects, e.g., some fullscreen games
+         * minimize if they lose focus. To avoid such side effects, err on the
+         * side of maintaining the Wine foreground state, with the expectation
+         * that the current foreground window will eventually also gain the
+         * Wayland keyboard focus. */
+        if (!foreground || foreground_is_mapped)
+        {
+            struct wayland_surface *toplevel = wayland_surface;
+            while (toplevel->parent) toplevel = toplevel->parent;
+            NtUserSetForegroundWindow(toplevel->hwnd);
+        }
+    }
+}
+
+static void CALLBACK maybe_unset_from_foreground(HWND hwnd, UINT msg,
+                                                 UINT_PTR timer_id,
+                                                 DWORD elapsed)
+{
+    struct wayland *wayland = thread_wayland();
+
+    TRACE("wayland=%p hwnd=%p\n", wayland, hwnd);
+
+    /* If no enter events have arrived since the previous leave event,
+     * the loss of focus was likely not transient, so drop the foreground state.
+     * We only drop the foreground state if it's ours to drop, i.e., some
+     * other window hasn't become foreground in the meantime. */
+    if (!wayland->keyboard.focused_surface && NtUserGetForegroundWindow() == hwnd)
+        NtUserSetForegroundWindow(NtUserGetDesktopWindow());
+
+    NtUserKillTimer(hwnd, timer_id);
+}
+
+static void keyboard_handle_leave(void *data, struct wl_keyboard *keyboard,
+        uint32_t serial, struct wl_surface *surface)
+{
+    struct wayland *wayland = data;
+    struct wayland_surface *focused_surface = wayland->keyboard.focused_surface;
+
+    if (focused_surface && focused_surface->wl_surface == surface)
+    {
+        TRACE("surface=%p hwnd=%p\n", focused_surface, focused_surface->hwnd);
+        NtUserKillTimer(focused_surface->hwnd, (UINT_PTR)keyboard);
+        /* This leave event may not signify a real loss of focus for the
+         * window. Such a case occurs when the focus changes from the main
+         * surface to a subsurface. Don't be too eager to lose the foreground
+         * state in such cases, as some fullscreen applications may become
+         * minimized. Instead wait a bit in case other enter events targeting a
+         * (sub)surface of the same HWND arrive soon after. */
+        NtUserSetTimer(focused_surface->hwnd,
+                       (UINT_PTR)&wayland->keyboard.focused_surface, 50,
+                       maybe_unset_from_foreground, TIMERV_DEFAULT_COALESCING);
+        wayland->keyboard.focused_surface = NULL;
+        wayland->keyboard.enter_serial = 0;
+    }
+}
+
+static void CALLBACK repeat_key(HWND hwnd, UINT msg, UINT_PTR timer_id, DWORD elapsed)
+{
+    struct wayland *wayland = thread_wayland();
+
+    if (wayland->keyboard.repeat_interval_ms > 0)
+    {
+        wayland_keyboard_emit(&wayland->keyboard, wayland->keyboard.pressed_key,
+                              WL_KEYBOARD_KEY_STATE_PRESSED, hwnd);
+
+        NtUserSetTimer(hwnd, timer_id, wayland->keyboard.repeat_interval_ms,
+                       repeat_key, TIMERV_DEFAULT_COALESCING);
+    }
+}
+
+static void keyboard_handle_key(void *data, struct wl_keyboard *keyboard,
+                                uint32_t serial, uint32_t time, uint32_t key,
+                                uint32_t state)
+{
+    struct wayland *wayland = data;
+    HWND focused_hwnd = wayland->keyboard.focused_surface ?
+                        wayland->keyboard.focused_surface->hwnd : 0;
+    UINT_PTR repeat_key_timer_id = (UINT_PTR)keyboard;
+
+    if (!focused_hwnd)
+        return;
+
+    TRACE("key=%d state=%#x focused_hwnd=%p\n", key, state, focused_hwnd);
+
+    wayland->last_dispatch_mask |= QS_KEY | QS_HOTKEY;
+
+    wayland_keyboard_emit(&wayland->keyboard, key, state, focused_hwnd);
+
+    if (state == WL_KEYBOARD_KEY_STATE_PRESSED)
+    {
+        wayland->keyboard.pressed_key = key;
+        if (wayland->keyboard.repeat_interval_ms > 0)
+        {
+            NtUserSetTimer(focused_hwnd, repeat_key_timer_id, wayland->keyboard.repeat_delay_ms,
+                           repeat_key, TIMERV_DEFAULT_COALESCING);
+        }
+    }
+    else
+    {
+        wayland->keyboard.pressed_key = 0;
+        NtUserKillTimer(focused_hwnd, repeat_key_timer_id);
+    }
+}
+
+static void keyboard_handle_modifiers(void *data, struct wl_keyboard *keyboard,
+                                      uint32_t serial, uint32_t mods_depressed,
+                                      uint32_t mods_latched, uint32_t mods_locked,
+                                      uint32_t group)
+{
+    struct wayland *wayland = data;
+
+    TRACE("depressed=0x%x latched=0x%x locked=0x%x group=%d\n",
+          mods_depressed, mods_latched, mods_locked, group);
+
+    if (!wayland->keyboard.xkb_state) return;
+
+    xkb_state_update_mask(wayland->keyboard.xkb_state,
+                          mods_depressed, mods_latched, mods_locked, 0, 0, group);
+
+    /* TODO: Sync wine modifier state with XKB modifier state. */
+}
+
+static void keyboard_handle_repeat_info(void *data, struct wl_keyboard *keyboard,
+                                        int rate, int delay)
+{
+    struct wayland *wayland = data;
+
+    TRACE("rate=%d delay=%d\n", rate, delay);
+
+    /* Handle non-negative rate values, ignore invalid (negative) values.  A
+     * rate of 0 disables repeat. Note that a requested rate value larger than
+     * 100 may not actually lead to the desired repeat rate, since we are
+     * constrained by the USER_TIMER_MINIMUM (=10ms) resolution of win32
+     * timers. */
+    if (rate > 1000)
+        wayland->keyboard.repeat_interval_ms = 1;
+    else if (rate > 0)
+        wayland->keyboard.repeat_interval_ms = 1000 / rate;
+    else if (rate == 0)
+        wayland->keyboard.repeat_interval_ms = 0;
+
+    wayland->keyboard.repeat_delay_ms = delay;
+}
+
+static const struct wl_keyboard_listener keyboard_listener = {
+    keyboard_handle_keymap,
+    keyboard_handle_enter,
+    keyboard_handle_leave,
+    keyboard_handle_key,
+    keyboard_handle_modifiers,
+    keyboard_handle_repeat_info,
+};
+
+/***********************************************************************
+ *           wayland_keyboard_init
+ */
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard)
+{
+    keyboard->wl_keyboard = wl_keyboard;
+    /* Some sensible default values for the repeat rate and delay. */
+    keyboard->repeat_interval_ms = 40;
+    keyboard->repeat_delay_ms = 400;
+    keyboard->xkb_context = xkb_context_new(XKB_CONTEXT_NO_FLAGS);
+    if (!keyboard->xkb_context)
+    {
+        ERR("Failed to create XKB context\n");
+        return;
+    }
+
+    wl_keyboard_add_listener(keyboard->wl_keyboard, &keyboard_listener, wayland);
+}
+
+/***********************************************************************
+ *           wayland_keyboard_deinit
+ */
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard)
+{
+    if (keyboard->wl_keyboard)
+        wl_keyboard_destroy(keyboard->wl_keyboard);
+
+    xkb_state_unref(keyboard->xkb_state);
+    xkb_context_unref(keyboard->xkb_context);
+
+    memset(keyboard, 0, sizeof(*keyboard));
+}
diff --git a/dlls/winewayland.drv/wayland_keyboard_layout.h b/dlls/winewayland.drv/wayland_keyboard_layout.h
new file mode 100644
index 00000000000..553264e22a4
--- /dev/null
+++ b/dlls/winewayland.drv/wayland_keyboard_layout.h
@@ -0,0 +1,287 @@
+/*
+ * Wayland keyboard driver layouts, adapted from X11 driver.
+ *
+ * This header file contains the tables used by keyboard_layout.c
+ * to perform layout mapping.
+ *
+ * Copyright 1993 Bob Amstadt
+ * Copyright 1996 Albrecht Kleine
+ * Copyright 1997 David Faure
+ * Copyright 1998 Morten Welinder
+ * Copyright 1998 Ulrich Weigand
+ * Copyright 1999 Ove KÃ¥ven
+ * Copyright 2021 Alexandros Frantzis
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#ifndef __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+#define __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H
+
+static const UINT xkb_keycode_to_vkey_us[] =
+{
+    0, 0, 0, 0, 0, 0, 0, 0,
+    0,                   /* KEY_RESERVED  0 */
+    VK_ESCAPE,           /* KEY_ESC   1 */
+    '1',                 /* KEY_1   2 */
+    '2',                 /* KEY_2   3 */
+    '3',                 /* KEY_3   4 */
+    '4',                 /* KEY_4   5 */
+    '5',                 /* KEY_5   6 */
+    '6',                 /* KEY_6   7 */
+    '7',                 /* KEY_7   8 */
+    '8',                 /* KEY_8   9 */
+    '9',                 /* KEY_9   10 */
+    '0',                 /* KEY_0   11 */
+    VK_OEM_MINUS,        /* KEY_MINUS  12 */
+    VK_OEM_PLUS,         /* KEY_EQUAL  13 */
+    VK_BACK,             /* KEY_BACKSPACE 14 */
+    VK_TAB,              /* KEY_TAB   15 */
+    'Q',                 /* KEY_Q   16 */
+    'W',                 /* KEY_W   17 */
+    'E',                 /* KEY_E   18 */
+    'R',                 /* KEY_R   19 */
+    'T',                 /* KEY_T   20 */
+    'Y',                 /* KEY_Y   21 */
+    'U',                 /* KEY_U   22 */
+    'I',                 /* KEY_I   23 */
+    'O',                 /* KEY_O   24 */
+    'P',                 /* KEY_P   25 */
+    VK_OEM_4,            /* KEY_LEFTBRACE  26 */
+    VK_OEM_6,            /* KEY_RIGHTBRACE  27 */
+    VK_RETURN,           /* KEY_ENTER  28 */
+    VK_LCONTROL,         /* KEY_LEFTCTRL  29 */
+    'A',                 /* KEY_A   30 */
+    'S',                 /* KEY_S   31 */
+    'D',                 /* KEY_D   32 */
+    'F',                 /* KEY_F   33 */
+    'G',                 /* KEY_G   34 */
+    'H',                 /* KEY_H   35 */
+    'J',                 /* KEY_J   36 */
+    'K',                 /* KEY_K   37 */
+    'L',                 /* KEY_L   38 */
+    VK_OEM_1,            /* KEY_SEMICOLON  39 */
+    VK_OEM_7,            /* KEY_APOSTROPHE  40 */
+    VK_OEM_3,            /* KEY_GRAVE  41 */
+    VK_LSHIFT,           /* KEY_LEFTSHIFT  42 */
+    VK_OEM_5,            /* KEY_BACKSLASH  43 */
+    'Z',                 /* KEY_Z   44 */
+    'X',                 /* KEY_X   45 */
+    'C',                 /* KEY_C   46 */
+    'V',                 /* KEY_V   47 */
+    'B',                 /* KEY_B   48 */
+    'N',                 /* KEY_N   49 */
+    'M',                 /* KEY_M   50 */
+    VK_OEM_COMMA,        /* KEY_COMMA  51 */
+    VK_OEM_PERIOD,       /* KEY_DOT   52 */
+    VK_OEM_2,            /* KEY_SLASH  53 */
+    VK_RSHIFT,           /* KEY_RIGHTSHIFT  54 */
+    VK_MULTIPLY,         /* KEY_KPASTERISK  55 */
+    VK_LMENU,            /* KEY_LEFTALT  56 */
+    VK_SPACE,            /* KEY_SPACE  57 */
+    VK_CAPITAL,          /* KEY_CAPSLOCK  58 */
+    VK_F1,               /* KEY_F1   59 */
+    VK_F2,               /* KEY_F2   60 */
+    VK_F3,               /* KEY_F3   61 */
+    VK_F4,               /* KEY_F4   62 */
+    VK_F5,               /* KEY_F5   63 */
+    VK_F6,               /* KEY_F6   64 */
+    VK_F7,               /* KEY_F7   65 */
+    VK_F8,               /* KEY_F8   66 */
+    VK_F9,               /* KEY_F9   67 */
+    VK_F10,              /* KEY_F10   68 */
+    VK_NUMLOCK,          /* KEY_NUMLOCK  69 */
+    VK_SCROLL,           /* KEY_SCROLLLOCK  70 */
+    VK_HOME,             /* KEY_KP7   71 */
+    VK_UP,               /* KEY_KP8   72 */
+    VK_PRIOR,            /* KEY_KP9   73 */
+    VK_SUBTRACT,         /* KEY_KPMINUS  74 */
+    VK_LEFT,             /* KEY_KP4   75 */
+    VK_CLEAR,            /* KEY_KP5   76 */
+    VK_RIGHT,            /* KEY_KP6   77 */
+    VK_ADD,              /* KEY_KPPLUS  78 */
+    VK_END,              /* KEY_KP1   79 */
+    VK_DOWN,             /* KEY_KP2   80 */
+    VK_NEXT,             /* KEY_KP3   81 */
+    VK_INSERT,           /* KEY_KP0   82 */
+    VK_DELETE,           /* KEY_KPDOT  83 */
+    0,                   /* 84 */
+    0,                   /* KEY_ZENKAKUHANKAKU 85 */
+    VK_OEM_102,          /* KEY_102ND  86 */
+    VK_F11,              /* KEY_F11   87 */
+    VK_F12,              /* KEY_F12   88 */
+    0,                   /* KEY_RO   89 */
+    0,                   /* KEY_KATAKANA  90 */
+    0,                   /* KEY_HIRAGANA  91 */
+    0,                   /* KEY_HENKAN  92 */
+    0,                   /* KEY_KATAKANAHIRAGANA 93 */
+    0,                   /* KEY_MUHENKAN  94 */
+    0,                   /* KEY_KPJPCOMMA  95 */
+    VK_RETURN,           /* KEY_KPENTER  96 */
+    VK_RCONTROL,         /* KEY_RIGHTCTRL  97 */
+    VK_DIVIDE,           /* KEY_KPSLASH  98 */
+    VK_SNAPSHOT,         /* KEY_SYSRQ  99 */
+    VK_RMENU,            /* KEY_RIGHTALT  100 */
+    0,                   /* KEY_LINEFEED  101 */
+    VK_HOME,             /* KEY_HOME  102 */
+    VK_UP,               /* KEY_UP   103 */
+    VK_PRIOR,            /* KEY_PAGEUP  104 */
+    VK_LEFT,             /* KEY_LEFT  105 */
+    VK_RIGHT,            /* KEY_RIGHT  106 */
+    VK_END,              /* KEY_END   107 */
+    VK_DOWN,             /* KEY_DOWN  108 */
+    VK_NEXT,             /* KEY_PAGEDOWN  109 */
+    VK_INSERT,           /* KEY_INSERT  110 */
+    VK_DELETE,           /* KEY_DELETE  111 */
+    0,                   /* KEY_MACRO  112 */
+    VK_VOLUME_MUTE,      /* KEY_MUTE  113 */
+    VK_VOLUME_DOWN,      /* KEY_VOLUMEDOWN  114 */
+    VK_VOLUME_UP,        /* KEY_VOLUMEUP  115 */
+    0,                   /* KEY_POWER  116  */
+    0,                   /* KEY_KPEQUAL  117 */
+    0,                   /* KEY_KPPLUSMINUS  118 */
+    VK_PAUSE,            /* KEY_PAUSE  119 */
+    0,                   /* KEY_SCALE  120  */
+    0,                   /* KEY_KPCOMMA  121 */
+    0,                   /* KEY_HANGEUL  122 */
+    0,                   /* KEY_HANJA  123 */
+    0,                   /* KEY_YEN   124 */
+    VK_LWIN,             /* KEY_LEFTMETA  125 */
+    VK_RWIN,             /* KEY_RIGHTMETA  126 */
+    0,                   /* KEY_COMPOSE  127 */
+    0,                   /* KEY_STOP  128  */
+    0,                   /* KEY_AGAIN  129 */
+    0,                   /* KEY_PROPS  130  */
+    0,                   /* KEY_UNDO  131  */
+    0,                   /* KEY_FRONT  132 */
+    0,                   /* KEY_COPY  133  */
+    0,                   /* KEY_OPEN  134  */
+    0,                   /* KEY_PASTE  135  */
+    0,                   /* KEY_FIND  136  */
+    0,                   /* KEY_CUT   137  */
+    0,                   /* KEY_HELP  138  */
+    0,                   /* KEY_MENU  139  */
+    0,                   /* KEY_CALC  140  */
+    0,                   /* KEY_SETUP  141 */
+    0,                   /* KEY_SLEEP  142  */
+    0,                   /* KEY_WAKEUP  143  */
+    0,                   /* KEY_FILE  144  */
+    0,                   /* KEY_SENDFILE  145 */
+    0,                   /* KEY_DELETEFILE  146 */
+    0,                   /* KEY_XFER  147 */
+    0,                   /* KEY_PROG1  148 */
+    0,                   /* KEY_PROG2  149 */
+    0,                   /* KEY_WWW   150  */
+    0,                   /* KEY_MSDOS  151 */
+    0,                   /* KEY_COFFEE  152 */
+    0,                   /* KEY_ROTATE_DISPLAY 153  */
+    0,                   /* KEY_CYCLEWINDOWS 154 */
+    0,                   /* KEY_MAIL  155 */
+    0,                   /* KEY_BOOKMARKS  156  */
+    0,                   /* KEY_COMPUTER  157 */
+    0,                   /* KEY_BACK  158  */
+    0,                   /* KEY_FORWARD  159  */
+    0,                   /* KEY_CLOSECD  160 */
+    0,                   /* KEY_EJECTCD  161 */
+    0,                   /* KEY_EJECTCLOSECD 162 */
+    VK_MEDIA_NEXT_TRACK, /* KEY_NEXTSONG  163 */
+    VK_MEDIA_PLAY_PAUSE, /* KEY_PLAYPAUSE  164 */
+    VK_MEDIA_PREV_TRACK, /* KEY_PREVIOUSSONG 165 */
+    0,                   /* KEY_STOPCD  166 */
+    0,                   /* KEY_RECORD  167 */
+    0,                   /* KEY_REWIND  168 */
+    0,                   /* KEY_PHONE  169  */
+    0,                   /* KEY_ISO   170 */
+    0,                   /* KEY_CONFIG  171  */
+    0,                   /* KEY_HOMEPAGE  172  */
+    0,                   /* KEY_REFRESH  173  */
+    0,                   /* KEY_EXIT  174  */
+    0,                   /* KEY_MOVE  175 */
+    0,                   /* KEY_EDIT  176 */
+    0,                   /* KEY_SCROLLUP  177 */
+    0,                   /* KEY_SCROLLDOWN  178 */
+    0,                   /* KEY_KPLEFTPAREN  179 */
+    0,                   /* KEY_KPRIGHTPAREN 180 */
+    0,                   /* KEY_NEW   181  */
+    0,                   /* KEY_REDO  182  */
+    VK_F13,              /* KEY_F13   183 */
+    VK_F14,              /* KEY_F14   184 */
+    VK_F15,              /* KEY_F15   185 */
+    VK_F16,              /* KEY_F16   186 */
+    VK_F17,              /* KEY_F17   187 */
+    VK_F18,              /* KEY_F18   188 */
+    VK_F19,              /* KEY_F19   189 */
+    VK_F20,              /* KEY_F20   190 */
+    VK_F21,              /* KEY_F21   191 */
+    VK_F22,              /* KEY_F22   192 */
+    VK_F23,              /* KEY_F23   193 */
+    VK_F24,              /* KEY_F24   194 */
+    0,                   /* 195 */
+    0,                   /* 196 */
+    0,                   /* 197 */
+    0,                   /* 198 */
+    0,                   /* 199 */
+    0,                   /* KEY_PLAYCD  200 */
+    0,                   /* KEY_PAUSECD  201 */
+    0,                   /* KEY_PROG3  202 */
+    0,                   /* KEY_PROG4  203 */
+    0,                   /* KEY_DASHBOARD  204  */
+    0,                   /* KEY_SUSPEND  205 */
+    0,                   /* KEY_CLOSE  206  */
+    VK_PLAY,             /* KEY_PLAY  207 */
+    0,                   /* KEY_FASTFORWARD  208 */
+    0,                   /* KEY_BASSBOOST  209 */
+    VK_PRINT,            /* KEY_PRINT  210  */
+    0,                   /* KEY_HP   211 */
+    0,                   /* KEY_CAMERA  212 */
+    0,                   /* KEY_SOUND  213 */
+    0,                   /* KEY_QUESTION  214  */
+    0,                   /* KEY_EMAIL  215 */
+    0,                   /* KEY_CHAT  216 */
+    0,                   /* KEY_SEARCH  217 */
+    0,                   /* KEY_CONNECT  218 */
+    0,                   /* KEY_FINANCE  219  */
+    0,                   /* KEY_SPORT  220 */
+    0,                   /* KEY_SHOP  221 */
+    0,                   /* KEY_ALTERASE  222 */
+    0,                   /* KEY_CANCEL  223  */
+    0,                   /* KEY_BRIGHTNESSDOWN 224 */
+    0,                   /* KEY_BRIGHTNESSUP 225 */
+    0,                   /* KEY_MEDIA  226 */
+    0,                   /* KEY_SWITCHVIDEOMODE 227  */
+    0,                   /* KEY_KBDILLUMTOGGLE 228 */
+    0,                   /* KEY_KBDILLUMDOWN 229 */
+    0,                   /* KEY_KBDILLUMUP  230 */
+    0,                   /* KEY_SEND  231  */
+    0,                   /* KEY_REPLY  232  */
+    0,                   /* KEY_FORWARDMAIL  233  */
+    0,                   /* KEY_SAVE  234  */
+    0,                   /* KEY_DOCUMENTS  235 */
+    0,                   /* KEY_BATTERY  236 */
+    0,                   /* KEY_BLUETOOTH  237 */
+    0,                   /* KEY_WLAN  238 */
+    0,                   /* KEY_UWB   239  */
+    0,                   /* KEY_UNKNOWN  240 */
+    0,                   /* KEY_VIDEO_NEXT  241  */
+    0,                   /* KEY_VIDEO_PREV  242  */
+    0,                   /* KEY_BRIGHTNESS_CYCLE 243  */
+    0,                   /* KEY_BRIGHTNESS_AUTO/ZERO 244 */
+    0,                   /* KEY_DISPLAY_OFF  245  */
+    0,                   /* KEY_WWAN  246  */
+    0,                   /* KEY_RFKILL  247  */
+    0,                   /* KEY_MICMUTE  248  */
+};
+
+#endif /* __WINE_WAYLANDDRV_WAYLAND_KEYBOARD_LAYOUT_H */
diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index 5e0377f43dc..540f565a1c8 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -402,12 +402,16 @@ BOOL wayland_surface_commit_buffer(struct wayland_surface *surface,
 void wayland_surface_destroy(struct wayland_surface *surface)
 {
     struct wayland_pointer *pointer = &surface->wayland->pointer;
+    struct wayland_keyboard *keyboard = &surface->wayland->keyboard;
 
     TRACE("surface=%p hwnd=%p\n", surface, surface->hwnd);
 
     if (pointer->focused_surface == surface)
         pointer->focused_surface = NULL;
 
+    if (keyboard->focused_surface == surface)
+        keyboard->focused_surface = NULL;
+
     if (surface->xdg_toplevel)
     {
         xdg_toplevel_destroy(surface->xdg_toplevel);
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 98eb41eb9ec..a53dae4c042 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -29,6 +29,7 @@
 #include <stdarg.h>
 #include <wayland-client.h>
 #include <wayland-cursor.h>
+#include <xkbcommon/xkbcommon.h>
 #include "xdg-output-unstable-v1-client-protocol.h"
 #include "xdg-shell-client-protocol.h"
 
@@ -60,6 +61,7 @@ enum wayland_window_message
     WM_WAYLAND_BROADCAST_DISPLAY_CHANGE = 0x80001000,
     WM_WAYLAND_MONITOR_CHANGE,
     WM_WAYLAND_SET_CURSOR,
+    WM_WAYLAND_QUERY_SURFACE_MAPPED,
 };
 
 enum wayland_surface_role
@@ -92,6 +94,18 @@ struct wayland_mutex
     const char *name;
 };
 
+struct wayland_keyboard
+{
+    struct wl_keyboard *wl_keyboard;
+    struct wayland_surface *focused_surface;
+    int repeat_interval_ms;
+    int repeat_delay_ms;
+    uint32_t pressed_key;
+    uint32_t enter_serial;
+    struct xkb_context *xkb_context;
+    struct xkb_state *xkb_state;
+};
+
 struct wayland_cursor
 {
     BOOL owns_wl_buffer;
@@ -131,6 +145,7 @@ struct wayland
     uint32_t next_fallback_output_id;
     struct wl_list output_list;
     struct wl_list detached_shm_buffer_list;
+    struct wayland_keyboard keyboard;
     struct wayland_pointer pointer;
     DWORD last_dispatch_mask;
     int event_notification_pipe[2];
@@ -370,6 +385,14 @@ BOOL wayland_window_surface_needs_flush(struct window_surface *surface) DECLSPEC
 void wayland_window_surface_update_wayland_surface(struct window_surface *surface,
                                                    struct wayland_surface *wayland_surface) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          Wayland Keyboard
+ */
+
+void wayland_keyboard_init(struct wayland_keyboard *keyboard, struct wayland *wayland,
+                           struct wl_keyboard *wl_keyboard) DECLSPEC_HIDDEN;
+void wayland_keyboard_deinit(struct wayland_keyboard *keyboard) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Wayland Pointer/Cursor
  */
@@ -399,6 +422,13 @@ DWORD reg_get_value_w(HKEY hkey, const WCHAR *nameW, ULONG type, char *buffer,
 DWORD reg_set_value_a(HKEY hkey, const char *name, ULONG type, const char *buffer,
                       DWORD buffer_len) DECLSPEC_HIDDEN;
 
+/**********************************************************************
+ *          XKB helpers
+ */
+
+xkb_layout_index_t _xkb_state_get_active_layout(struct xkb_state *xkb_state) DECLSPEC_HIDDEN;
+int _xkb_keysyms_to_utf8(const xkb_keysym_t *syms, int nsyms, char *utf8, int utf8_size) DECLSPEC_HIDDEN;
+
 /**********************************************************************
  *          Misc. helpers
  */
diff --git a/dlls/winewayland.drv/window.c b/dlls/winewayland.drv/window.c
index 820e90ed034..c9e3c7e8234 100644
--- a/dlls/winewayland.drv/window.c
+++ b/dlls/winewayland.drv/window.c
@@ -474,6 +474,15 @@ LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
         wayland_pointer_update_cursor_from_win32(&thread_wayland()->pointer,
                                                  (HCURSOR)lp);
         break;
+    case WM_WAYLAND_QUERY_SURFACE_MAPPED:
+        {
+            LRESULT res;
+            struct wayland_surface *wayland_surface = wayland_surface_for_hwnd_lock(hwnd);
+            res = wayland_surface ? wayland_surface->mapped : 0;
+            wayland_surface_for_hwnd_unlock(wayland_surface);
+            return res;
+        }
+        break;
     default:
         FIXME("got window msg %x hwnd %p wp %lx lp %lx\n", msg, hwnd, wp, lp);
     }
diff --git a/include/config.h.in b/include/config.h.in
index 04896af480e..4404fb0ff5d 100644
--- a/include/config.h.in
+++ b/include/config.h.in
@@ -760,6 +760,9 @@
 /* Define if you have the XKB extension */
 #undef HAVE_XKB
 
+/* Define to 1 if you have the <xkbcommon/xkbcommon.h> header file. */
+#undef HAVE_XKBCOMMON_XKBCOMMON_H
+
 /* Define if Xrender has the XRenderCreateLinearGradient function */
 #undef HAVE_XRENDERCREATELINEARGRADIENT
 
-- 
2.36.1

