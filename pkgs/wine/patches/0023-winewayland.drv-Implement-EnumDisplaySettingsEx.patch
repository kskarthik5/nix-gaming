From fe761bb131d7498735c120e884a947ba09f180ed Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Thu, 2 Sep 2021 15:34:01 +0300
Subject: [PATCH 023/170] winewayland.drv: Implement EnumDisplaySettingsEx.

Implement EnumDisplaySettingsEx by using the Wayland display output
information stored in the per-process instance.

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/display.c         | 232 +++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |   1 +
 dlls/winewayland.drv/waylanddrv_main.c |   1 +
 3 files changed, 234 insertions(+)

diff --git a/dlls/winewayland.drv/display.c b/dlls/winewayland.drv/display.c
index 1b71bc48aab..c3cc4beaa13 100644
--- a/dlls/winewayland.drv/display.c
+++ b/dlls/winewayland.drv/display.c
@@ -23,6 +23,9 @@
 #pragma makedep unix
 #endif
 
+#define NONAMELESSUNION
+#define NONAMELESSSTRUCT
+
 #include "config.h"
 
 #include "waylanddrv.h"
@@ -187,3 +190,232 @@ void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manage
 
     wayland_process_release();
 }
+
+static HANDLE acquire_display_devices_init_mutex(void)
+{
+    static const WCHAR init_mutexW[] = {'d','i','s','p','l','a','y','_',
+                                        'd','e','v','i','c','e','_','i','n','i','t'};
+    UNICODE_STRING name = {sizeof(init_mutexW), sizeof(init_mutexW), (WCHAR *)init_mutexW};
+    OBJECT_ATTRIBUTES attr;
+    HANDLE mutex = 0;
+
+    InitializeObjectAttributes(&attr, &name, OBJ_OPENIF, NULL, NULL);
+    NtCreateMutant(&mutex, MUTEX_ALL_ACCESS, &attr, FALSE);
+    if (mutex) NtWaitForSingleObject(mutex, FALSE, NULL);
+
+    return mutex;
+}
+
+static void release_display_devices_init_mutex(HANDLE mutex)
+{
+    NtReleaseMutant(mutex, NULL);
+    NtClose(mutex);
+}
+
+static HKEY get_display_device_reg_key(const WCHAR *device_name)
+{
+    static const WCHAR display[] = {'\\','\\','.','\\','D','I','S','P','L','A','Y'};
+    static const WCHAR video_key[] = {'\\','R','e','g','i','s','t','r','y',
+                                      '\\','M','a','c','h','i','n','e',
+                                      '\\','H','A','R','D','W','A','R','E',
+                                      '\\','D','E','V','I','C','E','M','A','P',
+                                      '\\','V','I','D','E','O',0};
+    static const WCHAR current_config_key[] = {
+        '\\','R','e','g','i','s','t','r','y',
+        '\\','M','a','c','h','i','n','e',
+        '\\','S','y','s','t','e','m',
+        '\\','C','u','r','r','e','n','t','C','o','n','t','r','o','l','S','e','t',
+        '\\','H','a','r','d','w','a','r','e',' ','P','r','o','f','i','l','e','s',
+        '\\','C','u','r','r','e','n','t'};
+    WCHAR value_name[MAX_PATH], buffer[4096], *end_ptr;
+    DWORD adapter_index, size, ret;
+    char adapter_name[128];
+    HKEY hkey;
+
+    /* Device name has to be \\.\DISPLAY%d */
+    if (wcsnicmp(device_name, display, ARRAY_SIZE(display)))
+        return FALSE;
+
+    /* Parse \\.\DISPLAY* */
+    adapter_index = unicode_z_to_long(device_name + ARRAY_SIZE(display), &end_ptr, 10) - 1;
+    if (*end_ptr)
+        return FALSE;
+
+    /* Open \Device\Video* in HKLM\HARDWARE\DEVICEMAP\VIDEO\ */
+    if (!(hkey = reg_open_key_w(NULL, video_key))) return FALSE;
+
+    size = snprintf(adapter_name, sizeof(adapter_name), "\\Device\\Video%d", adapter_index);
+    if (size > sizeof(adapter_name)) size = sizeof(adapter_name);
+    ascii_to_unicode_z(value_name, ARRAY_SIZE(value_name), adapter_name, size);
+
+    size = sizeof(buffer);
+    ret = reg_get_value_w(hkey, value_name, REG_SZ, (char *)buffer, &size);
+    NtClose(hkey);
+    if (ret || !size) return FALSE;
+
+    /* Replace \Registry\Machine\ prefix with HKEY_CURRENT_CONFIG */
+    memmove(buffer + ARRAYSIZE(current_config_key), buffer + 17,
+            size - 17 * sizeof(WCHAR));
+    memcpy(buffer, current_config_key, sizeof(current_config_key));
+    TRACE("display device %s registry settings key %s.\n",
+          wine_dbgstr_w(device_name), wine_dbgstr_w(buffer) );
+    return reg_open_key_w(NULL, buffer);
+}
+
+static BOOL read_registry_settings(const WCHAR *device_name, DEVMODEW *dm)
+{
+    HANDLE mutex;
+    HKEY hkey;
+    DWORD size;
+    BOOL ret = TRUE;
+
+    dm->dmFields = 0;
+
+    mutex = acquire_display_devices_init_mutex();
+    if (!(hkey = get_display_device_reg_key(device_name)))
+    {
+        ret = FALSE;
+        goto done;
+    }
+
+#define query_value(name, data) \
+    size = sizeof(DWORD); \
+    if (reg_get_value_a(hkey, name, REG_DWORD, (char *)(data), &size) || \
+        size != sizeof(DWORD)) \
+        ret = FALSE
+
+    query_value("DefaultSettings.BitsPerPel", &dm->dmBitsPerPel);
+    dm->dmFields |= DM_BITSPERPEL;
+    query_value("DefaultSettings.XResolution", &dm->dmPelsWidth);
+    dm->dmFields |= DM_PELSWIDTH;
+    query_value("DefaultSettings.YResolution", &dm->dmPelsHeight);
+    dm->dmFields |= DM_PELSHEIGHT;
+    query_value("DefaultSettings.VRefresh", &dm->dmDisplayFrequency);
+    dm->dmFields |= DM_DISPLAYFREQUENCY;
+    query_value("DefaultSettings.Flags", &dm->u2.dmDisplayFlags);
+    dm->dmFields |= DM_DISPLAYFLAGS;
+    query_value("DefaultSettings.XPanning", &dm->u1.s2.dmPosition.x);
+    query_value("DefaultSettings.YPanning", &dm->u1.s2.dmPosition.y);
+    dm->dmFields |= DM_POSITION;
+    query_value("DefaultSettings.Orientation", &dm->u1.s2.dmDisplayOrientation);
+    dm->dmFields |= DM_DISPLAYORIENTATION;
+    query_value("DefaultSettings.FixedOutput", &dm->u1.s2.dmDisplayFixedOutput);
+
+#undef query_value
+
+    NtClose(hkey);
+
+done:
+    release_display_devices_init_mutex(mutex);
+    return ret;
+}
+
+static void populate_devmode(struct wayland_output_mode *output_mode, DEVMODEW *mode)
+{
+    mode->dmFields = DM_DISPLAYORIENTATION | DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT |
+                     DM_DISPLAYFLAGS | DM_DISPLAYFREQUENCY | DM_POSITION;
+    mode->u1.s2.dmDisplayOrientation = DMDO_DEFAULT;
+    mode->u2.dmDisplayFlags = 0;
+    mode->u1.s2.dmPosition.x = 0;
+    mode->u1.s2.dmPosition.y = 0;
+    mode->dmBitsPerPel = output_mode->bpp;
+    mode->dmPelsWidth = output_mode->width;
+    mode->dmPelsHeight = output_mode->height;
+    mode->dmDisplayFrequency = output_mode->refresh / 1000;
+}
+
+static BOOL wayland_get_current_devmode(struct wayland *wayland, LPCWSTR name, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    if (!output->current_mode)
+        return FALSE;
+
+    populate_devmode(output->current_mode, mode);
+
+    return TRUE;
+}
+
+static BOOL wayland_get_devmode(struct wayland *wayland, LPCWSTR name, DWORD n, DEVMODEW *mode)
+{
+    struct wayland_output *output;
+    struct wayland_output_mode *output_mode;
+    DWORD i = 0;
+
+    output = wayland_output_get_by_wine_name(wayland, name);
+    if (!output)
+        return FALSE;
+
+    wl_list_for_each(output_mode, &output->mode_list, link)
+    {
+        if (i == n)
+        {
+            populate_devmode(output_mode, mode);
+            return TRUE;
+        }
+        i++;
+    }
+
+    return FALSE;
+}
+
+/***********************************************************************
+ *		EnumDisplaySettingsEx  (WAYLAND.@)
+ *
+ */
+BOOL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags)
+{
+    static const WCHAR dev_name[CCHDEVICENAME] =
+        {'W','i','n','e',' ','W','a','y','l','a','n','d',' ','d','r','i','v','e','r',0};
+    struct wayland *wayland = wayland_process_acquire();
+
+    TRACE("(%s,%d,%p,0x%08x) wayland=%p\n", debugstr_w(name), n, devmode, flags, wayland);
+
+    if (n == ENUM_REGISTRY_SETTINGS)
+    {
+        if (!read_registry_settings(name, devmode) &&
+            !wayland_get_current_devmode(wayland, name, devmode))
+        {
+            ERR("Failed to get %s registry display settings and native mode.\n",
+                wine_dbgstr_w(name));
+            goto err;
+        }
+        goto done;
+    }
+
+    if (n == ENUM_CURRENT_SETTINGS)
+    {
+        if (!wayland_get_current_devmode(wayland, name, devmode))
+        {
+            ERR("Failed to get %s current display settings.\n", wine_dbgstr_w(name));
+            goto err;
+        }
+        goto done;
+    }
+
+    if (!wayland_get_devmode(wayland, name, n, devmode))
+    {
+        WARN("Modes index out of range\n");
+        SetLastError(ERROR_NO_MORE_FILES);
+        goto err;
+    }
+
+done:
+    wayland_process_release();
+    TRACE("=> %dx%d\n", devmode->dmPelsWidth, devmode->dmPelsHeight);
+    /* Set generic fields */
+    devmode->dmSize = FIELD_OFFSET(DEVMODEW, dmICMMethod);
+    devmode->dmDriverExtra = 0;
+    devmode->dmSpecVersion = DM_SPECVERSION;
+    devmode->dmDriverVersion = DM_SPECVERSION;
+    lstrcpyW(devmode->dmDeviceName, dev_name);
+    return TRUE;
+
+err:
+    wayland_process_release();
+    return FALSE;
+}
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 463207a8cec..50555bf9d80 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -219,6 +219,7 @@ static inline LRESULT send_message_timeout(HWND hwnd, UINT msg, WPARAM wparam, L
  */
 
 BOOL WAYLAND_CreateWindow(HWND hwnd) DECLSPEC_HIDDEN;
+BOOL WAYLAND_EnumDisplaySettingsEx(LPCWSTR name, DWORD n, LPDEVMODEW devmode, DWORD flags) DECLSPEC_HIDDEN;
 void WAYLAND_UpdateDisplayDevices(const struct gdi_device_manager *device_manager,
                                   BOOL force, void *param) DECLSPEC_HIDDEN;
 LRESULT WAYLAND_WindowMessage(HWND hwnd, UINT msg, WPARAM wp, LPARAM lp) DECLSPEC_HIDDEN;
diff --git a/dlls/winewayland.drv/waylanddrv_main.c b/dlls/winewayland.drv/waylanddrv_main.c
index d08eb7838ea..49ad1b6c2ba 100644
--- a/dlls/winewayland.drv/waylanddrv_main.c
+++ b/dlls/winewayland.drv/waylanddrv_main.c
@@ -86,6 +86,7 @@ static void WAYLAND_ThreadDetach(void)
 static const struct user_driver_funcs waylanddrv_funcs =
 {
     .pCreateWindow = WAYLAND_CreateWindow,
+    .pEnumDisplaySettingsEx = WAYLAND_EnumDisplaySettingsEx,
     .pThreadDetach = WAYLAND_ThreadDetach,
     .pUpdateDisplayDevices = WAYLAND_UpdateDisplayDevices,
     .pWindowMessage = WAYLAND_WindowMessage,
-- 
2.36.1

