From d1f2ccd3108be0c8f31b9662e70a9ac2707d7092 Mon Sep 17 00:00:00 2001
From: Alexandros Frantzis <alexandros.frantzis@collabora.com>
Date: Tue, 14 Sep 2021 15:25:18 +0300
Subject: [PATCH 105/170] winewayland.drv: Add function to ensure a Wayland
 surface is mapped.

The contents of GL or Vulkan windows are rendered on subsurfaces with
the parent surface used for the decorations. Such GL/VK subsurfaces may
want to commit their contents before the parent surface has had a chance
to commit. In such cases the GL/VK commit will not be displayed, but,
more importantly, will not get a frame callback until the parent surface
is also committed. Depending on the presentation mode, a second GL/VK
buffer swap may indefinitely block waiting on the frame callback. By
calling this function before a GL/VK buffer swap we can avoid this
situation.

If the ancestor surfaces of GL/VK subsurface are subsurfaces themselves
we need to recursively ensure they are also mapped (fix proposed by
Alexander <alexander.>).

Signed-off-by: Alexandros Frantzis <alexandros.frantzis@collabora.com>
---
 dlls/winewayland.drv/wayland_surface.c | 82 ++++++++++++++++++++++++++
 dlls/winewayland.drv/waylanddrv.h      |  1 +
 2 files changed, 83 insertions(+)

diff --git a/dlls/winewayland.drv/wayland_surface.c b/dlls/winewayland.drv/wayland_surface.c
index d1253804b28..38d48744017 100644
--- a/dlls/winewayland.drv/wayland_surface.c
+++ b/dlls/winewayland.drv/wayland_surface.c
@@ -1105,6 +1105,88 @@ void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                    wine_width, wine_height);
 }
 
+static void dummy_buffer_release(void *data, struct wl_buffer *buffer)
+{
+    struct wayland_shm_buffer *shm_buffer = data;
+
+    TRACE("shm_buffer=%p\n", shm_buffer);
+
+    wayland_shm_buffer_destroy(shm_buffer);
+}
+
+static const struct wl_buffer_listener dummy_buffer_listener = {
+    dummy_buffer_release
+};
+
+/**********************************************************************
+ *          wayland_surface_ensure_mapped
+ *
+ * Ensure that the wayland surface is mapped, by committing a dummy
+ * buffer if necessary.
+ *
+ * The contents of GL or Vulkan windows are rendered on subsurfaces
+ * with the parent surface used for the decorations. Such GL/VK
+ * subsurfaces may want to commit their contents before the parent
+ * surface has had a chance to commit. In such cases the GL/VK commit
+ * will not be displayed, but, more importantly, will not get a frame
+ * callback until the parent surface is also committed. Depending on
+ * the presentation mode, a second GL/VK buffer swap may indefinitely
+ * block waiting on the frame callback. By calling this function before a
+ * GL/VK buffer swap we can avoid this situation.
+ */
+void wayland_surface_ensure_mapped(struct wayland_surface *surface)
+{
+    wayland_mutex_lock(&surface->mutex);
+
+    /* If this is a subsurface, ensure its parent is also mapped. */
+    if (surface->parent)
+        wayland_surface_ensure_mapped(surface->parent);
+
+    TRACE("surface=%p hwnd=%p mapped=%d\n",
+          surface, surface->hwnd, surface->mapped);
+
+    if (!surface->mapped)
+    {
+        int width = surface->current.width;
+        int height = surface->current.height;
+        int flags = surface->current.configure_flags;
+        int wine_width, wine_height;
+        struct wayland_shm_buffer *dummy_shm_buffer;
+        HRGN damage;
+
+        /* Use a large enough width/height, so even when the target
+         * surface is scaled by the compositor, this will not end up
+         * being 0x0. */
+        if (width == 0) width = 32;
+        if (height == 0) height = 32;
+
+        if ((flags & WAYLAND_CONFIGURE_FLAG_FULLSCREEN) &&
+            !(flags & WAYLAND_CONFIGURE_FLAG_MAXIMIZED))
+        {
+            wayland_surface_find_wine_fullscreen_fit(surface, width, height,
+                                                     &wine_width, &wine_height);
+        }
+        else
+        {
+            wayland_surface_coords_to_wine(surface, width, height,
+                                           &wine_width, &wine_height);
+        }
+
+        dummy_shm_buffer = wayland_shm_buffer_create(surface->wayland,
+                                                     wine_width, wine_height,
+                                                     WL_SHM_FORMAT_ARGB8888);
+        wl_buffer_add_listener(dummy_shm_buffer->wl_buffer,
+                               &dummy_buffer_listener, dummy_shm_buffer);
+
+        damage = NtGdiCreateRectRgn(0, 0, wine_width, wine_height);
+        if (!wayland_surface_commit_buffer(surface, dummy_shm_buffer, damage))
+            wayland_shm_buffer_destroy(dummy_shm_buffer);
+        NtGdiDeleteObjectApp(damage);
+    }
+
+    wayland_mutex_unlock(&surface->mutex);
+}
+
 /**********************************************************************
  *          wayland_surface_ref
  *
diff --git a/dlls/winewayland.drv/waylanddrv.h b/dlls/winewayland.drv/waylanddrv.h
index 0826092de01..2d64d19c5a7 100644
--- a/dlls/winewayland.drv/waylanddrv.h
+++ b/dlls/winewayland.drv/waylanddrv.h
@@ -424,6 +424,7 @@ void wayland_surface_coords_to_wine(struct wayland_surface *surface,
 void wayland_surface_find_wine_fullscreen_fit(struct wayland_surface *surface,
                                               int wayland_width, int wayland_height,
                                               int *wine_width, int *wine_height) DECLSPEC_HIDDEN;
+void wayland_surface_ensure_mapped(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 struct wayland_surface *wayland_surface_ref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_unref(struct wayland_surface *surface) DECLSPEC_HIDDEN;
 void wayland_surface_leave_output(struct wayland_surface *surface,
-- 
2.36.1

